<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARLib: arlib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image/png" href="arlib-logo-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="arlib-logo-32x32.png" sizes="32x32">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arlib-logo-100x100.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ARLib
   </div>
   <div id="projectbrief">An Alternative Route Planning Library for Boost.Graph</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">arlib Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An Alternative-Routing library for Boost.Graph.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacearlib_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html">details</a></td></tr>
<tr class="memdesc:namespacearlib_1_1details"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations details of kSPwLO algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1always__continue.html">always_continue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1BiDijkstraVisitor.html">BiDijkstraVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP interface class for <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a88897dfad3fa724d035439daed14b098" title="bidirectional_dijkstra()">bidirectional_dijkstra()</a> visitor.  <a href="classarlib_1_1BiDijkstraVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1IdentityBiDijkstraVisitor.html">IdentityBiDijkstraVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarlib_1_1BiDijkstraVisitor.html" title="CRTP interface class for bidirectional_dijkstra() visitor.">BiDijkstraVisitor</a> implementing vanilla Bidirectional Dijkstra behavior as described in Nicholson's paper (1966): <a href="https://academic.oup.com/comjnl/article/9/3/275/406281">https://academic.oup.com/comjnl/article/9/3/275/406281</a>.  <a href="classarlib_1_1IdentityBiDijkstraVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multi predecessor map records the edges in the alternative paths from a pair of <em>source-target</em> vertices.  <a href="classarlib_1_1multi__predecessor__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1Path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>view</em> of a graph to a simple path.  <a href="classarlib_1_1Path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1ReorderBuffer.html">ReorderBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1terminator.html">terminator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1terminator__stop__error.html">terminator_stop_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1timer.html">timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1UninformedBiPrunerVisitor.html">UninformedBiPrunerVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarlib_1_1BiDijkstraVisitor.html" title="CRTP interface class for bidirectional_dijkstra() visitor.">BiDijkstraVisitor</a> implementing Uninformed Bidirectional Pruner as described in.  <a href="classarlib_1_1UninformedBiPrunerVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a272ecadd6ec10654446c9986c892d006"><td class="memItemLeft" align="right" valign="top"><a id="a272ecadd6ec10654446c9986c892d006"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VPair</b> = std::pair&lt; long unsigned int, long unsigned int &gt;</td></tr>
<tr class="separator:a272ecadd6ec10654446c9986c892d006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d42e34ca4651a01eb6566d2d236757b"><td class="memItemLeft" align="right" valign="top"><a id="a6d42e34ca4651a01eb6566d2d236757b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CSRGraph</b> = boost::compressed_sparse_row_graph&lt; boost::bidirectionalS, boost::no_property, boost::property&lt; boost::edge_weight_t, double &gt; &gt;</td></tr>
<tr class="separator:a6d42e34ca4651a01eb6566d2d236757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa8ec091488d6d834c6d96c6695d5cc"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:aeaa8ec091488d6d834c6d96c6695d5cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#aeaa8ec091488d6d834c6d96c6695d5cc">vertex_of_t</a> = typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor</td></tr>
<tr class="memdesc:aeaa8ec091488d6d834c6d96c6695d5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to query a Graph <code>vertex descriptor</code> type.  <a href="#aeaa8ec091488d6d834c6d96c6695d5cc">More...</a><br /></td></tr>
<tr class="separator:aeaa8ec091488d6d834c6d96c6695d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44e6f831bf910b71d9d6880097d7ce1"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:af44e6f831bf910b71d9d6880097d7ce1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#af44e6f831bf910b71d9d6880097d7ce1">edge_of_t</a> = typename boost::graph_traits&lt; Graph &gt;::edge_descriptor</td></tr>
<tr class="memdesc:af44e6f831bf910b71d9d6880097d7ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to query a Graph <code>edge descriptor</code> type.  <a href="#af44e6f831bf910b71d9d6880097d7ce1">More...</a><br /></td></tr>
<tr class="separator:af44e6f831bf910b71d9d6880097d7ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ba4bdd7dfde4292dce219e65832fb9"><td class="memTemplParams" colspan="2">template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ab8ba4bdd7dfde4292dce219e65832fb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ab8ba4bdd7dfde4292dce219e65832fb9">key_of_t</a> = typename boost::property_traits&lt; Map &gt;::key_type</td></tr>
<tr class="memdesc:ab8ba4bdd7dfde4292dce219e65832fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to query a <code>Property Map</code>'s <code>key</code> type.  <a href="#ab8ba4bdd7dfde4292dce219e65832fb9">More...</a><br /></td></tr>
<tr class="separator:ab8ba4bdd7dfde4292dce219e65832fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c152c2b32bd635dad808511c84ddb01"><td class="memTemplParams" colspan="2">template&lt;typename Map &gt; </td></tr>
<tr class="memitem:a5c152c2b32bd635dad808511c84ddb01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a5c152c2b32bd635dad808511c84ddb01">value_of_t</a> = typename boost::property_traits&lt; Map &gt;::value_type</td></tr>
<tr class="memdesc:a5c152c2b32bd635dad808511c84ddb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to query a <code>Property Map</code>'s <code>value</code> type.  <a href="#a5c152c2b32bd635dad808511c84ddb01">More...</a><br /></td></tr>
<tr class="separator:a5c152c2b32bd635dad808511c84ddb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2dbd999a3ebf5ec76a90ee460b866b"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a6c2dbd999a3ebf5ec76a90ee460b866b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a6c2dbd999a3ebf5ec76a90ee460b866b">length_of_t</a> = typename boost::property_traits&lt; typename boost::property_map&lt; Graph, boost::edge_weight_t &gt;::type &gt;::value_type</td></tr>
<tr class="memdesc:a6c2dbd999a3ebf5ec76a90ee460b866b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to query a Graph <code>edge_weight</code> value type.  <a href="#a6c2dbd999a3ebf5ec76a90ee460b866b">More...</a><br /></td></tr>
<tr class="separator:a6c2dbd999a3ebf5ec76a90ee460b866b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f6fb01a4bc9fd0e9c6b8ec1bd6119c"><td class="memTemplParams" colspan="2"><a id="ac4f6fb01a4bc9fd0e9c6b8ec1bd6119c"></a>
template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ac4f6fb01a4bc9fd0e9c6b8ec1bd6119c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrunedGraph</b> = boost::filtered_graph&lt; Graph, <a class="el" href="structarlib_1_1details_1_1pruned__edges.html">details::pruned_edges</a>&lt; <a class="el" href="namespacearlib.html#af44e6f831bf910b71d9d6880097d7ce1">edge_of_t</a>&lt; Graph &gt; &gt;&gt;</td></tr>
<tr class="separator:ac4f6fb01a4bc9fd0e9c6b8ec1bd6119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a544f6817e2696d89923463118a457575"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> { <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11">routing_kernels::dijkstra</a> = 1, 
<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a>, 
<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a88897dfad3fa724d035439daed14b098">routing_kernels::bidirectional_dijkstra</a>
 }</td></tr>
<tr class="memdesc:a544f6817e2696d89923463118a457575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routing kernel names in ARLib.  <a href="namespacearlib.html#a544f6817e2696d89923463118a457575">More...</a><br /></td></tr>
<tr class="separator:a544f6817e2696d89923463118a457575"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20b1e034171566886e8391008e920077"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;              typename boost::property_traits&lt;MultiPredecessorMap&gt;::key_type,              Vertex&gt;&gt;&gt; </td></tr>
<tr class="memitem:a20b1e034171566886e8391008e920077"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a20b1e034171566886e8391008e920077">esx</a> (const Graph &amp;G, WeightMap const &amp;weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm=<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a>, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="memdesc:a20b1e034171566886e8391008e920077"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of ESX k-shortest path with limited overlap for Boost::Graph.  <a href="#a20b1e034171566886e8391008e920077">More...</a><br /></td></tr>
<tr class="separator:a20b1e034171566886e8391008e920077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b6484cb155157afa38336afa3c57bb"><td class="memTemplParams" colspan="2"><a id="a68b6484cb155157afa38336afa3c57bb"></a>
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename EdgeCentralityMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;              typename boost::property_traits&lt;MultiPredecessorMap&gt;::key_type,              Vertex&gt;&gt;&gt; </td></tr>
<tr class="memitem:a68b6484cb155157afa38336afa3c57bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>esx</b> (const Graph &amp;G, WeightMap const &amp;weight, MultiPredecessorMap &amp;predecessors, EdgeCentralityMap const &amp;edge_centrality, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm=<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a>, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="separator:a68b6484cb155157afa38336afa3c57bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1fc85816e5cd39c8ea8fb67f942088"><td class="memTemplParams" colspan="2">template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;              typename boost::property_traits&lt;MultiPredecessorMap&gt;::key_type,              Vertex&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7e1fc85816e5cd39c8ea8fb67f942088"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a7e1fc85816e5cd39c8ea8fb67f942088">esx</a> (const PropertyGraph &amp;G, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm=<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a>, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="memdesc:a7e1fc85816e5cd39c8ea8fb67f942088"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <code>ESX</code> k-shortest path with limited overlap for <code>Boost::Graph</code>.  <a href="#a7e1fc85816e5cd39c8ea8fb67f942088">More...</a><br /></td></tr>
<tr class="separator:a7e1fc85816e5cd39c8ea8fb67f942088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4c568ec0c6235b5143944637e91079"><td class="memTemplParams" colspan="2"><a id="a3b4c568ec0c6235b5143944637e91079"></a>
template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename EdgeCentralityMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;              typename boost::property_traits&lt;MultiPredecessorMap&gt;::key_type,              Vertex&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3b4c568ec0c6235b5143944637e91079"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>esx</b> (const PropertyGraph &amp;G, MultiPredecessorMap &amp;predecessors, EdgeCentralityMap const &amp;edge_centrality, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm=<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a>, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="separator:a3b4c568ec0c6235b5143944637e91079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80a6aa5be5526e7b8fea77181a43047"><td class="memItemLeft" align="right" valign="top"><a id="aa80a6aa5be5526e7b8fea77181a43047"></a>
CSRGraph&#160;</td><td class="memItemRight" valign="bottom"><b>read_csr_graph_from_string</b> (const std::string &amp;graph)</td></tr>
<tr class="separator:aa80a6aa5be5526e7b8fea77181a43047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593977b6aef3410a48ad5879ddcba675"><td class="memItemLeft" align="right" valign="top"><a id="a593977b6aef3410a48ad5879ddcba675"></a>
std::optional&lt; CSRGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>read_csr_graph_from_file</b> (const std::string_view path)</td></tr>
<tr class="separator:a593977b6aef3410a48ad5879ddcba675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b1d53ad607d09f8468bf1160922f03"><td class="memTemplParams" colspan="2">template&lt;typename PropertyGraph &gt; </td></tr>
<tr class="memitem:a52b1d53ad607d09f8468bf1160922f03"><td class="memTemplItemLeft" align="right" valign="top">PropertyGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a52b1d53ad607d09f8468bf1160922f03">read_graph_from_string</a> (const std::string &amp;graph)</td></tr>
<tr class="memdesc:a52b1d53ad607d09f8468bf1160922f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PropertyGraph from vertices, edges and weights contained in a .gr-format string.  <a href="#a52b1d53ad607d09f8468bf1160922f03">More...</a><br /></td></tr>
<tr class="separator:a52b1d53ad607d09f8468bf1160922f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff994557e051789268b4af7d339a510"><td class="memTemplParams" colspan="2"><a id="a4ff994557e051789268b4af7d339a510"></a>
template&lt;typename PropertyGraph &gt; </td></tr>
<tr class="memitem:a4ff994557e051789268b4af7d339a510"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; PropertyGraph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_graph_from_file</b> (const std::string_view path)</td></tr>
<tr class="separator:a4ff994557e051789268b4af7d339a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a035996961e93d88e639e7cbd0b6b87"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a2a035996961e93d88e639e7cbd0b6b87"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a2a035996961e93d88e639e7cbd0b6b87">dump_edges_weight</a> (const Graph &amp;G)</td></tr>
<tr class="memdesc:a2a035996961e93d88e639e7cbd0b6b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string representation of a graph edges and their weight.  <a href="#a2a035996961e93d88e639e7cbd0b6b87">More...</a><br /></td></tr>
<tr class="separator:a2a035996961e93d88e639e7cbd0b6b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c7bad2efc884be598a231c23571f17"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:af7c7bad2efc884be598a231c23571f17"><td class="memTemplItemLeft" align="right" valign="top">Graph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#af7c7bad2efc884be598a231c23571f17">build_graph_from_edges</a> (const std::vector&lt; VPair &gt; &amp;edge_list, const Graph &amp;G)</td></tr>
<tr class="memdesc:af7c7bad2efc884be598a231c23571f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Graph from a vector of edges, taking their weights from another graph.  <a href="#af7c7bad2efc884be598a231c23571f17">More...</a><br /></td></tr>
<tr class="separator:af7c7bad2efc884be598a231c23571f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27c035af61ff36fe460da949d256634"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:af27c035af61ff36fe460da949d256634"><td class="memTemplItemLeft" align="right" valign="top">Graph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#af27c035af61ff36fe460da949d256634">build_AG</a> (const std::vector&lt; <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt;&gt; &amp;paths, const Graph &amp;g)</td></tr>
<tr class="memdesc:af27c035af61ff36fe460da949d256634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a href="http://drops.dagstuhl.de/opus/volltexte/2013/4248/">Alternative Graph</a> from a sequence of paths, taking their weights from another source graph.  <a href="#af27c035af61ff36fe460da949d256634">More...</a><br /></td></tr>
<tr class="separator:af27c035af61ff36fe460da949d256634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b12c71af39769d06f27eb9ecd7e894b"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a3b12c71af39769d06f27eb9ecd7e894b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a3b12c71af39769d06f27eb9ecd7e894b">to_paths</a> (Graph const &amp;G, <a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex &gt; &amp;pmap, WeightMap const &amp;weight, Vertex s, Vertex t)</td></tr>
<tr class="memdesc:a3b12c71af39769d06f27eb9ecd7e894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sequence of <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a graph <code>G</code> a pair of source-target vertices a <a class="el" href="classarlib_1_1multi__predecessor__map.html" title="The multi predecessor map records the edges in the alternative paths from a pair of source-target ver...">multi_predecessor_map</a> holding alternative paths from <code>s</code> to <code>t</code>.  <a href="#a3b12c71af39769d06f27eb9ecd7e894b">More...</a><br /></td></tr>
<tr class="separator:a3b12c71af39769d06f27eb9ecd7e894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980037f9960a8321e47f2fb2c9a3e58d"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a980037f9960a8321e47f2fb2c9a3e58d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a980037f9960a8321e47f2fb2c9a3e58d">to_paths</a> (Graph const &amp;G, <a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex &gt; &amp;pmap, Vertex s, Vertex t)</td></tr>
<tr class="memdesc:a980037f9960a8321e47f2fb2c9a3e58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sequence of <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a graph <code>G</code> a pair of source-target vertices a <a class="el" href="classarlib_1_1multi__predecessor__map.html" title="The multi predecessor map records the edges in the alternative paths from a pair of source-target ver...">multi_predecessor_map</a> holding alternative paths from <code>s</code> to <code>t</code>.  <a href="#a980037f9960a8321e47f2fb2c9a3e58d">More...</a><br /></td></tr>
<tr class="separator:a980037f9960a8321e47f2fb2c9a3e58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc237487ff092abb2268c7e632c7ced"><td class="memTemplParams" colspan="2">template&lt;typename Vertex2 , typename Key &gt; </td></tr>
<tr class="memitem:a9dc237487ff092abb2268c7e632c7ced"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex2 &gt;::reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a9dc237487ff092abb2268c7e632c7ced">get</a> (<a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex2 &gt; &amp;pmap, Key const &amp;k)</td></tr>
<tr class="memdesc:a9dc237487ff092abb2268c7e632c7ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the value associated with <code>k</code>  <a href="#a9dc237487ff092abb2268c7e632c7ced">More...</a><br /></td></tr>
<tr class="separator:a9dc237487ff092abb2268c7e632c7ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbaf6f6c794b39a8b465c0e24ce1920"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a9bbaf6f6c794b39a8b465c0e24ce1920"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a9bbaf6f6c794b39a8b465c0e24ce1920">onepass_plus</a> (const Graph &amp;G, WeightMap weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="memdesc:a9bbaf6f6c794b39a8b465c0e24ce1920"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph.  <a href="#a9bbaf6f6c794b39a8b465c0e24ce1920">More...</a><br /></td></tr>
<tr class="separator:a9bbaf6f6c794b39a8b465c0e24ce1920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983cd9e7b81cbf49410a9624afe40449"><td class="memTemplParams" colspan="2">template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;&gt; </td></tr>
<tr class="memitem:a983cd9e7b81cbf49410a9624afe40449"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a983cd9e7b81cbf49410a9624afe40449">onepass_plus</a> (const PropertyGraph &amp;G, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="memdesc:a983cd9e7b81cbf49410a9624afe40449"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph.  <a href="#a983cd9e7b81cbf49410a9624afe40449">More...</a><br /></td></tr>
<tr class="separator:a983cd9e7b81cbf49410a9624afe40449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7fed81b11f052d5c7a55ac285ebc80"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a7f7fed81b11f052d5c7a55ac285ebc80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a7f7fed81b11f052d5c7a55ac285ebc80">swap</a> (<a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &amp;v1, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &amp;v2)</td></tr>
<tr class="memdesc:a7f7fed81b11f052d5c7a55ac285ebc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap between two <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>.  <a href="#a7f7fed81b11f052d5c7a55ac285ebc80">More...</a><br /></td></tr>
<tr class="separator:a7f7fed81b11f052d5c7a55ac285ebc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6881494557c2cced6fe5d76be940cd3e"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a6881494557c2cced6fe5d76be940cd3e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::out_edge_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::out_edge_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a6881494557c2cced6fe5d76be940cd3e">out_edges</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor u, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:a6881494557c2cced6fe5d76be940cd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb330378567ebeb6c35d4260ab966132"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:aeb330378567ebeb6c35d4260ab966132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#aeb330378567ebeb6c35d4260ab966132">source</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_descriptor e, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:aeb330378567ebeb6c35d4260ab966132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eb5c6f53c6c87f7b8529192e0e5335"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a71eb5c6f53c6c87f7b8529192e0e5335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a71eb5c6f53c6c87f7b8529192e0e5335">target</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_descriptor e, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:a71eb5c6f53c6c87f7b8529192e0e5335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0f85330dd338b0515509ec3ca31ef5"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:abf0f85330dd338b0515509ec3ca31ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::degree_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#abf0f85330dd338b0515509ec3ca31ef5">out_degree</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor u, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:abf0f85330dd338b0515509ec3ca31ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b41e3be39a0fcdd206434ba039b4a0"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a22b41e3be39a0fcdd206434ba039b4a0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::in_edge_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::in_edge_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a22b41e3be39a0fcdd206434ba039b4a0">in_edges</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor v, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:a22b41e3be39a0fcdd206434ba039b4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4543147b7871a677d93a95e86b5bf4d8"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a4543147b7871a677d93a95e86b5bf4d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::degree_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a4543147b7871a677d93a95e86b5bf4d8">in_degree</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor v, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:a4543147b7871a677d93a95e86b5bf4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e068813ed4ada4a5c40c29ea234b1ae"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a3e068813ed4ada4a5c40c29ea234b1ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::degree_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a3e068813ed4ada4a5c40c29ea234b1ae">degree</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor v, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:a3e068813ed4ada4a5c40c29ea234b1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65978d2c3c2944063b2b5ea4b29ef34"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:ae65978d2c3c2944063b2b5ea4b29ef34"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::adjacency_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::adjacency_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ae65978d2c3c2944063b2b5ea4b29ef34">adjacent_vertices</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor v, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:ae65978d2c3c2944063b2b5ea4b29ef34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7de2abf351c71c8728e4c1a15add11"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:acb7de2abf351c71c8728e4c1a15add11"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#acb7de2abf351c71c8728e4c1a15add11">vertices</a> (<a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:acb7de2abf351c71c8728e4c1a15add11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8428e527cab71d1b7cc67e4f23e681"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:aeb8428e527cab71d1b7cc67e4f23e681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertices_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#aeb8428e527cab71d1b7cc67e4f23e681">num_vertices</a> (<a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:aeb8428e527cab71d1b7cc67e4f23e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a051bb3a91e5100056da794cfaa9dd"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:ae0a051bb3a91e5100056da794cfaa9dd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ae0a051bb3a91e5100056da794cfaa9dd">edges</a> (<a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:ae0a051bb3a91e5100056da794cfaa9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8c5bb0424d16dc9b6741b53e3afb34"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a2f8c5bb0424d16dc9b6741b53e3afb34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edges_size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a2f8c5bb0424d16dc9b6741b53e3afb34">num_edges</a> (<a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:a2f8c5bb0424d16dc9b6741b53e3afb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b074c30fd1cdc0b0274688c1dd4ad"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:ac79b074c30fd1cdc0b0274688c1dd4ad"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_descriptor, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ac79b074c30fd1cdc0b0274688c1dd4ad">edge</a> (typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor u, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor v, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;g)</td></tr>
<tr class="separator:ac79b074c30fd1cdc0b0274688c1dd4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c4d667aec7dce4bba4072e04efdaee"><td class="memTemplParams" colspan="2">template&lt;typename G , typename Property &gt; </td></tr>
<tr class="memitem:a22c4d667aec7dce4bba4072e04efdaee"><td class="memTemplItemLeft" align="right" valign="top">boost::property_map&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::FilteredGraph, Property &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a22c4d667aec7dce4bba4072e04efdaee">get</a> (Property p, <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;g)</td></tr>
<tr class="separator:a22c4d667aec7dce4bba4072e04efdaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6595b39413ef7b4beaad4ac46c7cb1f0"><td class="memTemplParams" colspan="2">template&lt;typename G , typename Property &gt; </td></tr>
<tr class="memitem:a6595b39413ef7b4beaad4ac46c7cb1f0"><td class="memTemplItemLeft" align="right" valign="top">boost::property_map&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::FilteredGraph, Property &gt;::const_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a6595b39413ef7b4beaad4ac46c7cb1f0">get</a> (Property p, const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;g)</td></tr>
<tr class="separator:a6595b39413ef7b4beaad4ac46c7cb1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63be623d64a098635e9ec0644425783b"><td class="memTemplParams" colspan="2">template&lt;typename G , typename Property , typename Key &gt; </td></tr>
<tr class="memitem:a63be623d64a098635e9ec0644425783b"><td class="memTemplItemLeft" align="right" valign="top">boost::property_map_value&lt; typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::FilteredGraph, Property &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a63be623d64a098635e9ec0644425783b">get</a> (Property p, const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;g, const Key &amp;k)</td></tr>
<tr class="separator:a63be623d64a098635e9ec0644425783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca11da6d0140c6317a4e9a72a2cc4cac"><td class="memTemplParams" colspan="2">template&lt;typename G , typename Property , typename Key , typename Value &gt; </td></tr>
<tr class="memitem:aca11da6d0140c6317a4e9a72a2cc4cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#aca11da6d0140c6317a4e9a72a2cc4cac">put</a> (Property p, const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;g, const Key &amp;k, const Value &amp;val)</td></tr>
<tr class="memdesc:aca11da6d0140c6317a4e9a72a2cc4cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the property value for <code>k</code> to <code>val</code>.  <a href="#aca11da6d0140c6317a4e9a72a2cc4cac">More...</a><br /></td></tr>
<tr class="separator:aca11da6d0140c6317a4e9a72a2cc4cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a70e9efa9e7dfc55ecf0536830105ee"><td class="memTemplParams" colspan="2"><a id="a3a70e9efa9e7dfc55ecf0536830105ee"></a>
template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a3a70e9efa9e7dfc55ecf0536830105ee"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; boost::filtered_graph&lt; Graph, <a class="el" href="structarlib_1_1details_1_1alternative__path__edges.html">details::alternative_path_edges</a>&lt; Edge &gt;, <a class="el" href="structarlib_1_1details_1_1alternative__path__vertices.html">details::alternative_path_vertices</a>&lt; Vertex &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_path_filtered_graph</b> (Graph const &amp;G, std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt; const &amp;<a class="el" href="namespacearlib.html#ae0a051bb3a91e5100056da794cfaa9dd">edges</a>, std::unordered_set&lt; Vertex, boost::hash&lt; Vertex &gt;&gt; const &amp;<a class="el" href="namespacearlib.html#acb7de2abf351c71c8728e4c1a15add11">vertices</a>)</td></tr>
<tr class="separator:a3a70e9efa9e7dfc55ecf0536830105ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2773ae67f2344c8b66767e91d22a24ed"><td class="memTemplParams" colspan="2"><a id="a2773ae67f2344c8b66767e91d22a24ed"></a>
template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a2773ae67f2344c8b66767e91d22a24ed"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; boost::filtered_graph&lt; Graph, <a class="el" href="structarlib_1_1details_1_1alternative__path__edges.html">details::alternative_path_edges</a>&lt; Edge &gt;, <a class="el" href="structarlib_1_1details_1_1alternative__path__vertices.html">details::alternative_path_vertices</a>&lt; Vertex &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_path_filtered_graph</b> (Graph const &amp;G, std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt; &amp;&amp;<a class="el" href="namespacearlib.html#ae0a051bb3a91e5100056da794cfaa9dd">edges</a>, std::unordered_set&lt; Vertex, boost::hash&lt; Vertex &gt;&gt; &amp;&amp;<a class="el" href="namespacearlib.html#acb7de2abf351c71c8728e4c1a15add11">vertices</a>)</td></tr>
<tr class="separator:a2773ae67f2344c8b66767e91d22a24ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1720f9aeeba81d08a6b40732d7492bb7"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a1720f9aeeba81d08a6b40732d7492bb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a1720f9aeeba81d08a6b40732d7492bb7">penalty</a> (const Graph &amp;G, WeightMap const &amp;original_weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, double p, double r, int max_nb_updates, int max_nb_steps, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm=<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11">routing_kernels::dijkstra</a>, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="memdesc:a1720f9aeeba81d08a6b40732d7492bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of Penalty method to compute alternative routes for Boost::Graph.  <a href="#a1720f9aeeba81d08a6b40732d7492bb7">More...</a><br /></td></tr>
<tr class="separator:a1720f9aeeba81d08a6b40732d7492bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48a2b0626ec88d3de2616204d9d1c1c"><td class="memTemplParams" colspan="2">template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;&gt; </td></tr>
<tr class="memitem:ad48a2b0626ec88d3de2616204d9d1c1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ad48a2b0626ec88d3de2616204d9d1c1c">penalty</a> (const PropertyGraph &amp;G, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, double p, double r, int max_nb_updates, int max_nb_steps, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm=<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11">routing_kernels::dijkstra</a>, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>=Terminator{})</td></tr>
<tr class="memdesc:ad48a2b0626ec88d3de2616204d9d1c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of Penalty method to compute alternative routes for Boost::Graph.  <a href="#ad48a2b0626ec88d3de2616204d9d1c1c">More...</a><br /></td></tr>
<tr class="separator:ad48a2b0626ec88d3de2616204d9d1c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faaab97ab54b2cace47a7fcb09622aa"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename BackGraph , typename BackPredecessorMap , typename BackDistanceMap , typename BackWeightMap , typename BiDijkstraVisitorImpl , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a8faaab97ab54b2cace47a7fcb09622aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a8faaab97ab54b2cace47a7fcb09622aa">bidirectional_dijkstra</a> (const Graph &amp;G, Vertex s, Vertex t, PredecessorMap predecessor, DistanceMap distance, WeightMap weight, const BackGraph &amp;G_b, BackPredecessorMap predecessor_b, BackDistanceMap distance_b, BackWeightMap weight_b, <a class="el" href="classarlib_1_1BiDijkstraVisitor.html">BiDijkstraVisitor</a>&lt; BiDijkstraVisitorImpl &gt; &amp;visitor)</td></tr>
<tr class="memdesc:a8faaab97ab54b2cace47a7fcb09622aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between two vertices.  <a href="#a8faaab97ab54b2cace47a7fcb09622aa">More...</a><br /></td></tr>
<tr class="separator:a8faaab97ab54b2cace47a7fcb09622aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9071f8b0f7b80738e93f81a9a7ea03ed"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename BackGraph , typename BackWeightMap , typename BackIndexMap , typename BiDijkstraVisitorImpl , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a9071f8b0f7b80738e93f81a9a7ea03ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a9071f8b0f7b80738e93f81a9a7ea03ed">bidirectional_dijkstra</a> (const Graph &amp;G, Vertex s, Vertex t, PredecessorMap predecessor, DistanceMap distance, WeightMap weight, const BackGraph &amp;G_b, BackWeightMap weight_b, BackIndexMap index_map_b, <a class="el" href="classarlib_1_1BiDijkstraVisitor.html">BiDijkstraVisitor</a>&lt; BiDijkstraVisitorImpl &gt; &amp;visitor)</td></tr>
<tr class="memdesc:a9071f8b0f7b80738e93f81a9a7ea03ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between two vertices.  <a href="#a9071f8b0f7b80738e93f81a9a7ea03ed">More...</a><br /></td></tr>
<tr class="separator:a9071f8b0f7b80738e93f81a9a7ea03ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c16e98fca5d64059389fea0c2dcbb6"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename BackGraph , typename BackWeightMap , typename BackIndexMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:ab7c16e98fca5d64059389fea0c2dcbb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ab7c16e98fca5d64059389fea0c2dcbb6">bidirectional_dijkstra</a> (const Graph &amp;G, Vertex s, Vertex t, PredecessorMap predecessor, DistanceMap distance, WeightMap weight, const BackGraph &amp;G_b, BackWeightMap weight_b, BackIndexMap index_map_b)</td></tr>
<tr class="memdesc:ab7c16e98fca5d64059389fea0c2dcbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between two vertices.  <a href="#ab7c16e98fca5d64059389fea0c2dcbb6">More...</a><br /></td></tr>
<tr class="separator:ab7c16e98fca5d64059389fea0c2dcbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ddf3055e80291bf2137784d826b501"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename RevWeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a70ddf3055e80291bf2137784d826b501"><td class="memTemplItemLeft" align="right" valign="top">PrunedGraph&lt; Graph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#a70ddf3055e80291bf2137784d826b501">uninformed_bidirectional_pruner</a> (const Graph &amp;G, WeightMap const &amp;weight_f, boost::reverse_graph&lt; Graph &gt; const &amp;rev_G, RevWeightMap const &amp;weight_b, Vertex s, Vertex t, double tau)</td></tr>
<tr class="memdesc:a70ddf3055e80291bf2137784d826b501"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of Uninformed Bidirectional Pruning for Boost::Graph.  <a href="#a70ddf3055e80291bf2137784d826b501">More...</a><br /></td></tr>
<tr class="separator:a70ddf3055e80291bf2137784d826b501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73bbe06c2f53c51686902c48db5ab4a"><td class="memTemplParams" colspan="2">template&lt;typename PropertyGraph , typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;&gt; </td></tr>
<tr class="memitem:ab73bbe06c2f53c51686902c48db5ab4a"><td class="memTemplItemLeft" align="right" valign="top">PrunedGraph&lt; PropertyGraph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib.html#ab73bbe06c2f53c51686902c48db5ab4a">uninformed_bidirectional_pruner</a> (const PropertyGraph &amp;G, Vertex s, Vertex t, double tau)</td></tr>
<tr class="memdesc:ab73bbe06c2f53c51686902c48db5ab4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of Uninformed Bidirectional Pruning for Boost::Graph.  <a href="#ab73bbe06c2f53c51686902c48db5ab4a">More...</a><br /></td></tr>
<tr class="separator:ab73bbe06c2f53c51686902c48db5ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An Alternative-Routing library for Boost.Graph. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af44e6f831bf910b71d9d6880097d7ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44e6f831bf910b71d9d6880097d7ce1">&#9670;&nbsp;</a></span>edge_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib.html#af44e6f831bf910b71d9d6880097d7ce1">arlib::edge_of_t</a> = typedef typename boost::graph_traits&lt;Graph&gt;::edge_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type to query a Graph <code>edge descriptor</code> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>The graph type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ba4bdd7dfde4292dce219e65832fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ba4bdd7dfde4292dce219e65832fb9">&#9670;&nbsp;</a></span>key_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib.html#ab8ba4bdd7dfde4292dce219e65832fb9">arlib::key_of_t</a> = typedef typename boost::property_traits&lt;Map&gt;::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type to query a <code>Property Map</code>'s <code>key</code> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Map</td><td>The property map type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c2dbd999a3ebf5ec76a90ee460b866b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2dbd999a3ebf5ec76a90ee460b866b">&#9670;&nbsp;</a></span>length_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib.html#a6c2dbd999a3ebf5ec76a90ee460b866b">arlib::length_of_t</a> = typedef typename boost::property_traits&lt;typename boost::property_map&lt; Graph, boost::edge_weight_t&gt;::type&gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type to query a Graph <code>edge_weight</code> value type. </p>
<p>For instance, given a Graph type: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Graph = boost::adjacency_list&lt;boost::vecS, boost::vecS,</div><div class="line">                                    boost::bidirectionalS,</div><div class="line">                                    boost::no_property,</div><div class="line">                                    boost::property&lt;</div><div class="line">                                      boost::edge_weight_t, <span class="keywordtype">int</span>&gt;&gt;;</div></div><!-- fragment --><p> The following expression is <code>true</code> </p><div class="fragment"><div class="line">std::is_same_v&lt;length_of_t&lt;Graph&gt;, <span class="keywordtype">int</span>&gt;</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c152c2b32bd635dad808511c84ddb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c152c2b32bd635dad808511c84ddb01">&#9670;&nbsp;</a></span>value_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Map &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib.html#a5c152c2b32bd635dad808511c84ddb01">arlib::value_of_t</a> = typedef typename boost::property_traits&lt;Map&gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type to query a <code>Property Map</code>'s <code>value</code> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Map</td><td>The property map type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaa8ec091488d6d834c6d96c6695d5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa8ec091488d6d834c6d96c6695d5cc">&#9670;&nbsp;</a></span>vertex_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib.html#aeaa8ec091488d6d834c6d96c6695d5cc">arlib::vertex_of_t</a> = typedef typename boost::graph_traits&lt;Graph&gt;::vertex_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type to query a Graph <code>vertex descriptor</code> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>The graph type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a544f6817e2696d89923463118a457575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544f6817e2696d89923463118a457575">&#9670;&nbsp;</a></span>routing_kernels</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">arlib::routing_kernels</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routing kernel names in ARLib. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11"></a>dijkstra&#160;</td><td class="fielddoc"><p>Standard Dijkstra's Algorithm. </p>
</td></tr>
<tr><td class="fieldname"><a id="a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b"></a>astar&#160;</td><td class="fielddoc"><p>An heuristic-driven variant of Dijkstra's Algorithm. </p>
</td></tr>
<tr><td class="fieldname"><a id="a544f6817e2696d89923463118a457575a88897dfad3fa724d035439daed14b098"></a>bidirectional_dijkstra&#160;</td><td class="fielddoc"><p><a class="el" href="namespacearlib.html#a8faaab97ab54b2cace47a7fcb09622aa" title="Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between...">bidirectional_dijkstra()</a> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae65978d2c3c2944063b2b5ea4b29ef34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65978d2c3c2944063b2b5ea4b29ef34">&#9670;&nbsp;</a></span>adjacent_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::adjacency_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::adjacency_iterator&gt; arlib::adjacent_vertices </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An iterator-range providing access to the vertices adjacent to vertex <code>v</code> in graph <code>g</code>. </dd></dl>

</div>
</div>
<a id="a8faaab97ab54b2cace47a7fcb09622aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faaab97ab54b2cace47a7fcb09622aa">&#9670;&nbsp;</a></span>bidirectional_dijkstra() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename BackGraph , typename BackPredecessorMap , typename BackDistanceMap , typename BackWeightMap , typename BiDijkstraVisitorImpl , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::bidirectional_dijkstra </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredecessorMap&#160;</td>
          <td class="paramname"><em>predecessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistanceMap&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BackGraph &amp;&#160;</td>
          <td class="paramname"><em>G_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackPredecessorMap&#160;</td>
          <td class="paramname"><em>predecessor_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackDistanceMap&#160;</td>
          <td class="paramname"><em>distance_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackWeightMap&#160;</td>
          <td class="paramname"><em>weight_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1BiDijkstraVisitor.html">BiDijkstraVisitor</a>&lt; BiDijkstraVisitorImpl &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between two vertices. </p>
<p>This implementation follows the one from nx.graph library: <a href="https://networkx.github.io/documentation/networkx-1.10/_modules/networkx/algorithms/shortest_paths/weighted.html#bidirectional_dijkstra">https://networkx.github.io/documentation/networkx-1.10/_modules/networkx/algorithms/shortest_paths/weighted.html#bidirectional_dijkstra</a></p>
<p>You can find the original paper by Nicholson (1996) <a href="https://academic.oup.com/comjnl/article/9/3/275/406281">https://academic.oup.com/comjnl/article/9/3/275/406281</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::VertexAndEdgeListGraph </td></tr>
    <tr><td class="paramname">PredecessorMap</td><td>The predecessor map records the edges in the shortest path tree, the tree computed by the traversal of the graph. Upon completion of the algorithm, the edges (p[u],u) for all u in V are in the tree. The shortest path from vertex s to each vertex v in the graph consists of the vertices v, p[v], p[p[v]], and so on until s is reached, in reverse order. The tree is not guaranteed to be a minimum spanning tree. If p[u] = u then u is either the source vertex or a vertex that is not reachable from the source. The PredecessorMap type must be a Read/Write Property Map whose key and value types are the same as the vertex descriptor type of the graph. </td></tr>
    <tr><td class="paramname">DistanceMap</td><td>The shortest path weight from the source vertex s to each vertex in the graph g is recorded in this property map. The shortest path weight is the sum of the edge weights along the shortest path. The type DistanceMap must be a model of Read/Write Property Map. The vertex descriptor type of the graph needs to be usable as the key type of the distance map. </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or `&lsquo;length&rsquo;' of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
    <tr><td class="paramname">BackGraph</td><td>A boost::reverse_graph&lt;Graph&gt; </td></tr>
    <tr><td class="paramname">BackPredecessorMap</td><td>A PredecessorMap of a boost::reverse_graph&lt;Graph&gt; </td></tr>
    <tr><td class="paramname">BackDistanceMap</td><td>A DistanceMap of a boost::reverse_graph&lt;Graph&gt; </td></tr>
    <tr><td class="paramname">BackWeightMap</td><td>A WeightMap of a boost::reverse_graph&lt;Graph&gt; </td></tr>
    <tr><td class="paramname">BiDijkstraVisitorImpl</td><td>An implementation of a <a class="el" href="classarlib_1_1BiDijkstraVisitor.html" title="CRTP interface class for bidirectional_dijkstra() visitor.">BiDijkstraVisitor</a>. </td></tr>
    <tr><td class="paramname">Vertex</td><td>a vertex_descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
    <tr><td class="paramname">predecessor</td><td>The PredecessorMap for the forward step. </td></tr>
    <tr><td class="paramname">distance</td><td>The DistanceMap for the forward step. </td></tr>
    <tr><td class="paramname">weight</td><td>The WeightMap for the forward step. </td></tr>
    <tr><td class="paramname">G_b</td><td>A boost::reverse_graph&lt;Graph&gt; of <code>G</code>. </td></tr>
    <tr><td class="paramname">predecessor_b</td><td>The PredecessorMap for the backward step. </td></tr>
    <tr><td class="paramname">distance_b</td><td>The DistanceMap for the backward step. </td></tr>
    <tr><td class="paramname">weight_b</td><td>The WeightMap for the backward step. </td></tr>
    <tr><td class="paramname">visitor</td><td>An implementation of a <a class="el" href="classarlib_1_1BiDijkstraVisitor.html" title="CRTP interface class for bidirectional_dijkstra() visitor.">BiDijkstraVisitor</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7c16e98fca5d64059389fea0c2dcbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c16e98fca5d64059389fea0c2dcbb6">&#9670;&nbsp;</a></span>bidirectional_dijkstra() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename BackGraph , typename BackWeightMap , typename BackIndexMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::bidirectional_dijkstra </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredecessorMap&#160;</td>
          <td class="paramname"><em>predecessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistanceMap&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BackGraph &amp;&#160;</td>
          <td class="paramname"><em>G_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackWeightMap&#160;</td>
          <td class="paramname"><em>weight_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackIndexMap&#160;</td>
          <td class="paramname"><em>index_map_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between two vertices. </p>
<p>This overload does not need a PredecessorMap nor a DistanceMap for the backward step nor a <a class="el" href="classarlib_1_1BiDijkstraVisitor.html" title="CRTP interface class for bidirectional_dijkstra() visitor.">BiDijkstraVisitor</a>. This simply runs Bidirectional Dijkstra.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacearlib.html#a8faaab97ab54b2cace47a7fcb09622aa" title="Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between...">bidirectional_dijkstra</a>(const Graph &amp;G, Vertex s, Vertex t, PredecessorMap predecessor, DistanceMap distance, WeightMap weight, const BackGraph &amp;G_b, BackPredecessorMap predecessor_b, BackDistanceMap distance_b, BackWeightMap weight_b, BiDijkstraVisitor&lt;BiDijkstraVisitorImpl&gt; &amp;visitor)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BackIndexMap</td><td>This maps each vertex to an integer in the range [0, num_vertices(g)). This is necessary for efficient updates of the heap data structure [61] when an edge is relaxed. The type VertexIndexMap must be a model of Readable Property Map. The value type of the map must be an integer type. The vertex descriptor type of the graph needs to be usable as the key type of the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9071f8b0f7b80738e93f81a9a7ea03ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9071f8b0f7b80738e93f81a9a7ea03ed">&#9670;&nbsp;</a></span>bidirectional_dijkstra() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename BackGraph , typename BackWeightMap , typename BackIndexMap , typename BiDijkstraVisitorImpl , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::bidirectional_dijkstra </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredecessorMap&#160;</td>
          <td class="paramname"><em>predecessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistanceMap&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BackGraph &amp;&#160;</td>
          <td class="paramname"><em>G_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackWeightMap&#160;</td>
          <td class="paramname"><em>weight_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackIndexMap&#160;</td>
          <td class="paramname"><em>index_map_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1BiDijkstraVisitor.html">BiDijkstraVisitor</a>&lt; BiDijkstraVisitorImpl &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between two vertices. </p>
<p>This overload does not need a PredecessorMap nor a DistanceMap for the backward step.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacearlib.html#a8faaab97ab54b2cace47a7fcb09622aa" title="Implementation of Bidirectional Dijkstra method for Boost::Graph to compute the shortest path between...">bidirectional_dijkstra</a>(const Graph &amp;G, Vertex s, Vertex t, PredecessorMap predecessor, DistanceMap distance, WeightMap weight, const BackGraph &amp;G_b, BackPredecessorMap predecessor_b, BackDistanceMap distance_b, BackWeightMap weight_b, BiDijkstraVisitor&lt;BiDijkstraVisitorImpl&gt; &amp;visitor)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BackIndexMap</td><td>This maps each vertex to an integer in the range [0, num_vertices(g)). This is necessary for efficient updates of the heap data structure [61] when an edge is relaxed. The type VertexIndexMap must be a model of Readable Property Map. The value type of the map must be an integer type. The vertex descriptor type of the graph needs to be usable as the key type of the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af27c035af61ff36fe460da949d256634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27c035af61ff36fe460da949d256634">&#9670;&nbsp;</a></span>build_AG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Graph arlib::build_AG </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a href="http://drops.dagstuhl.de/opus/volltexte/2013/4248/">Alternative Graph</a> from a sequence of paths, taking their weights from another source graph. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Edges in <code>paths</code> exist in <code>g</code>. If not, the behavior is undefined.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>The type of the output graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>A vector of simple paths. </td></tr>
    <tr><td class="paramname">g</td><td>The source graph from where to take <code>edge_list</code> edges' weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed graph. </dd></dl>

</div>
</div>
<a id="af7c7bad2efc884be598a231c23571f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c7bad2efc884be598a231c23571f17">&#9670;&nbsp;</a></span>build_graph_from_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Graph arlib::build_graph_from_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VPair &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Graph from a vector of edges, taking their weights from another graph. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Edges in <code>edge_list</code> exist in <code>G</code>. If not, the behavior is undefined.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>The type of the output graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_list</td><td>Vector of <code>(vertex_id, vertex_id)</code> edges. </td></tr>
    <tr><td class="paramname">G</td><td>The source graph from where to take <code>edge_list</code> edges' weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed graph. </dd></dl>

</div>
</div>
<a id="a3e068813ed4ada4a5c40c29ea234b1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e068813ed4ada4a5c40c29ea234b1ae">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::degree_size_type arlib::degree </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of in-edges plus out-edges (for directed graphs) or the number of incident edges (for undirected graphs) of vertex <code>v</code> in graph <code>g</code>. </dd></dl>

</div>
</div>
<a id="a2a035996961e93d88e639e7cbd0b6b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a035996961e93d88e639e7cbd0b6b87">&#9670;&nbsp;</a></span>dump_edges_weight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string arlib::dump_edges_weight </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string representation of a graph edges and their weight. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A model of EdgeListGraph </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights dump </dd></dl>

</div>
</div>
<a id="ac79b074c30fd1cdc0b0274688c1dd4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79b074c30fd1cdc0b0274688c1dd4ad">&#9670;&nbsp;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::edge_descriptor, bool&gt; arlib::edge </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The edge connecting vertex <code>u</code> to vertex <code>v</code> in graph <code>g</code>. </dd></dl>

</div>
</div>
<a id="ae0a051bb3a91e5100056da794cfaa9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a051bb3a91e5100056da794cfaa9dd">&#9670;&nbsp;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::edge_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::edge_iterator&gt; arlib::edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An iterator-range providing access to the edge set of graph <code>g</code>. </dd></dl>

</div>
</div>
<a id="a20b1e034171566886e8391008e920077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b1e034171566886e8391008e920077">&#9670;&nbsp;</a></span>esx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;              typename boost::property_traits&lt;MultiPredecessorMap&gt;::key_type,              Vertex&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::esx </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiPredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a>&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Terminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>Terminator{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of ESX k-shortest path with limited overlap for Boost::Graph. </p>
<p>This implementation refers to the following publication:</p>
<p>Theodoros Chondrogiannis, Panagiotis Bouros, Johann Gamper and Ulf Leser, Exact and Approximate Algorithms for Finding k-Shortest Paths with Limited Overlap , In Proc. of the 20th Int. Conf. on Extending Database Technology (EDBT) (2017)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::VertexAndEdgeListGraph </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or "length" of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
    <tr><td class="paramname">MultiPredecessorMap</td><td>The multi predecessor map records the edges in the alternative paths from <code>s</code> to <code>t</code>. Upon completion of the algorithm, for any vertex <code>v</code> on any alternative path <code>p</code>, multi predecessor map stores the predecessor of node <code>v</code> on path <code>p</code>. If no predecessor for a node &lsquo;v&rsquo;<code>is reported, then</code>v'` is not part of any alternative path or it is the source node <code>s</code>. The type of <code>MultiPredecessorMap</code> must be a model of <code>Read Property Map</code>. The vertex descriptor of the input graph <code>G</code> must be usable as a key type for the multi predecessor map. Whereas the value type must satisfy the <code>UnorderedAssociativeContainer</code> concept, where its key is an <code>int</code>, the index/number of alternative path for which it exists a predecessor of <code>v</code>, and where the value type is a vertex descriptor of input graph <code>G</code>. </td></tr>
    <tr><td class="paramname">Vertex</td><td>The vertex descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The input graph. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight map of <code>G</code>. </td></tr>
    <tr><td class="paramname">predecessors</td><td>The multi predecessor map of <code>G</code>. </td></tr>
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">k</td><td>The number of alternative paths to compute. </td></tr>
    <tr><td class="paramname">theta</td><td>The similarity threshold. </td></tr>
    <tr><td class="paramname">algorithm</td><td>The routing kernel to employ. The default is <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b" title="An heuristic-driven variant of Dijkstra&#39;s Algorithm.">routing_kernels::astar</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e1fc85816e5cd39c8ea8fb67f942088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1fc85816e5cd39c8ea8fb67f942088">&#9670;&nbsp;</a></span>esx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;              typename boost::property_traits&lt;MultiPredecessorMap&gt;::key_type,              Vertex&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::esx </td>
          <td>(</td>
          <td class="paramtype">const PropertyGraph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiPredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a>&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a5cf61d8cbe928c561127a605715c383b">routing_kernels::astar</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Terminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>Terminator{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of <code>ESX</code> k-shortest path with limited overlap for <code>Boost::Graph</code>. </p>
<p>This overload takes an input graph modeling <code>PropertyGraph</code> concept having at least one edge property with tag <code>boost::edge_weight_t</code>. Moreover it does not require an explicit <code>WeightMap</code> parameter, because it is directly gathered from the <code>PropertyGraph</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacearlib.html#a20b1e034171566886e8391008e920077" title="An implementation of ESX k-shortest path with limited overlap for Boost::Graph.">esx</a>(const Graph &amp;G, WeightMap const &amp;weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575" title="Routing kernel names in ARLib.">routing_kernels</a> algorithm)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropertyGraph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dc237487ff092abb2268c7e632c7ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc237487ff092abb2268c7e632c7ced">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vertex2 , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt;Vertex2&gt;::reference arlib::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key const &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the value associated with <code>k</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MultiPredecessorMap</td><td>The multi predecessor map records the edges in the alternative paths from <code>s</code> to <code>t</code>. Upon completion of the algorithm, for any vertex <code>v</code> on any alternative path <code>p</code>, multi predecessor map stores the predecessor of node <code>v</code> on path <code>p</code>. If no predecessor for a node &lsquo;v&rsquo;<code>is reported, then</code>v'` is not part of any alternative path or it is the source node <code>s</code>. The type of <code>MultiPredecessorMap</code> must be a model of <code>Read Property Map</code>. The vertex descriptor of the input graph <code>G</code> must be usable as a key type for the multi predecessor map. Whereas the value type must satisfy the <code>UnorderedAssociativeContainer</code> concept, where its key is an <code>int</code>, the index/number of alternative path for which it exists a predecessor of <code>v</code>, and where the value type is a vertex descriptor of input graph <code>G</code>. </td></tr>
    <tr><td class="paramname">Key</td><td>Must be a valid key type for <code>MultiPredecessorMap</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmap</td><td>The <code>MultiPredecessorMap</code> to get value from. </td></tr>
    <tr><td class="paramname">k</td><td>The key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value associated with <code>k</code>. </dd></dl>

</div>
</div>
<a id="a6595b39413ef7b4beaad4ac46c7cb1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6595b39413ef7b4beaad4ac46c7cb1f0">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename Property &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::property_map&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::FilteredGraph, Property&gt;::const_type arlib::get </td>
          <td>(</td>
          <td class="paramtype">Property&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The property map object for the vertex property specified by <code>Property</code>. The <code>Property</code> must match one of the properties specified in the graph's <code>VertexProperty</code> template argument. </dd></dl>

</div>
</div>
<a id="a63be623d64a098635e9ec0644425783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63be623d64a098635e9ec0644425783b">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename Property , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::property_map_value&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::FilteredGraph, Property&gt;::type arlib::get </td>
          <td>(</td>
          <td class="paramtype">Property&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The property value for <code>k</code>, where <code>k</code> is either a vertex or edge descriptor </dd></dl>

</div>
</div>
<a id="a22c4d667aec7dce4bba4072e04efdaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c4d667aec7dce4bba4072e04efdaee">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename Property &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::property_map&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::FilteredGraph, Property&gt;::type arlib::get </td>
          <td>(</td>
          <td class="paramtype">Property&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The property map object for the vertex property specified by <code>Property</code>. The <code>Property</code> must match one of the properties specified in the graph's <code>VertexProperty</code> template argument. </dd></dl>

</div>
</div>
<a id="a4543147b7871a677d93a95e86b5bf4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4543147b7871a677d93a95e86b5bf4d8">&#9670;&nbsp;</a></span>in_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::degree_size_type arlib::in_degree </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of edges entering vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a22b41e3be39a0fcdd206434ba039b4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b41e3be39a0fcdd206434ba039b4a0">&#9670;&nbsp;</a></span>in_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::in_edge_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::in_edge_iterator&gt; arlib::in_edges </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An iterator-range providing access to the in-edges of vertex <code>v</code> in graph <code>g</code>. For an in-edge <code>e</code>, <code>target(e, g) == v</code> and <code>source(e, g) == u</code> for some vertex <code>u</code> that is adjacent to <code>v</code>, whether the graph is directed or undirected. </dd></dl>

</div>
</div>
<a id="a2f8c5bb0424d16dc9b6741b53e3afb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8c5bb0424d16dc9b6741b53e3afb34">&#9670;&nbsp;</a></span>num_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::edges_size_type arlib::num_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of edges in the underlying graph. </dd></dl>

</div>
</div>
<a id="aeb8428e527cab71d1b7cc67e4f23e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8428e527cab71d1b7cc67e4f23e681">&#9670;&nbsp;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::vertices_size_type arlib::num_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of vertices in the underlying graph. </dd></dl>

</div>
</div>
<a id="a9bbaf6f6c794b39a8b465c0e24ce1920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbaf6f6c794b39a8b465c0e24ce1920">&#9670;&nbsp;</a></span>onepass_plus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::onepass_plus </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiPredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Terminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>Terminator{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph. </p>
<p>This implementation refers to the following publication: Theodoros Chondrogiannis, Panagiotis Bouros, Johann Gamper and Ulf Leser, Exact and Approximate Algorithms for Finding k-Shortest Paths with Limited Overlap , In Proc. of the 20th Int. Conf. on Extending Database Technology (EDBT) (2017)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::VertexAndEdgeListGraph </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or "length" of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
    <tr><td class="paramname">MultiPredecessorMap</td><td>The multi predecessor map records the edges in the alternative paths from <code>s</code> to <code>t</code>. Upon completion of the algorithm, for any vertex <code>v</code> on any alternative path <code>p</code>, multi predecessor map stores the predecessor of node <code>v</code> on path <code>p</code>. If no predecessor for a node &lsquo;v&rsquo;<code>is reported, then</code>v'` is not part of any alternative path or it is the source node <code>s</code>. The type of <code>MultiPredecessorMap</code> must be a model of <code>Read Property Map</code>. The vertex descriptor of the input graph <code>G</code> must be usable as a key type for the multi predecessor map. Whereas the value type must satisfy the <code>UnorderedAssociativeContainer</code> concept, where its key is an <code>int</code>, the index/number of alternative path for which it exists a predecessor of <code>v</code>, and where the value type is a vertex descriptor of input graph <code>G</code>. </td></tr>
    <tr><td class="paramname">Vertex</td><td>The vertex descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The input graph. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight map of <code>G</code>. </td></tr>
    <tr><td class="paramname">predecessors</td><td>The multi predecessor map of <code>G</code>. </td></tr>
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">k</td><td>The number of alternative paths to compute. </td></tr>
    <tr><td class="paramname">theta</td><td>The similarity threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a983cd9e7b81cbf49410a9624afe40449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983cd9e7b81cbf49410a9624afe40449">&#9670;&nbsp;</a></span>onepass_plus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::onepass_plus </td>
          <td>(</td>
          <td class="paramtype">const PropertyGraph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiPredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Terminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>Terminator{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph. </p>
<p>This overload takes an input graph modeling <code>PropertyGraph</code> concept having at least one edge property with tag <code>boost::edge_weight_t</code>. Moreover it does not require an explicit <code>WeightMap</code> parameter, because it is directly gathered from the <code>PropertyGraph</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacearlib.html#a9bbaf6f6c794b39a8b465c0e24ce1920" title="An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph.">onepass_plus</a>(const Graph &amp;G, WeightMap weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropertyGraph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf0f85330dd338b0515509ec3ca31ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0f85330dd338b0515509ec3ca31ef5">&#9670;&nbsp;</a></span>out_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::degree_size_type arlib::out_degree </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of edges leaving vertex <code>u</code>. </dd></dl>

</div>
</div>
<a id="a6881494557c2cced6fe5d76be940cd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6881494557c2cced6fe5d76be940cd3e">&#9670;&nbsp;</a></span>out_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::out_edge_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::out_edge_iterator&gt; arlib::out_edges </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An iterator-range providing access to the out-edges of vertex <code>u</code> in graph <code>g</code>. If the graph is undirected, this iterator-range provides access to all edges incident on vertex <code>u</code>. For both directed and undirected graphs, for an out-edge <code>e</code>, <code>source(e, g) == u</code> and <code>target(e, g) == v</code> where <code>v</code> is a vertex adjacent to <code>u</code>. </dd></dl>

</div>
</div>
<a id="a1720f9aeeba81d08a6b40732d7492bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1720f9aeeba81d08a6b40732d7492bb7">&#9670;&nbsp;</a></span>penalty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::penalty </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap const &amp;&#160;</td>
          <td class="paramname"><em>original_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiPredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_nb_updates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_nb_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a>&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11">routing_kernels::dijkstra</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Terminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>Terminator{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of Penalty method to compute alternative routes for Boost::Graph. </p>
<p>This implementation refers to the following publication: Andreas Paraskevopoulos, Christos Zaroliagis. Improved Alternative Route Planning. Daniele Frigioni and Sebastian Stiller. ATMOS - 13th Workshop on Algorithmic Approaches for Transportation Modelling, Optimization, and Systems - 2013, Sep 2013, Sophia Antipolis, France.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::VertexAndEdgeListGraph </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or "length" of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
    <tr><td class="paramname">MultiPredecessorMap</td><td>The multi predecessor map records the edges in the alternative paths from <code>s</code> to <code>t</code>. Upon completion of the algorithm, for any vertex <code>v</code> on any alternative path <code>p</code>, multi predecessor map stores the predecessor of node <code>v</code> on path <code>p</code>. If no predecessor for a node &lsquo;v&rsquo;<code>is reported, then</code>v'` is not part of any alternative path or it is the source node <code>s</code>. The type of <code>MultiPredecessorMap</code> must be a model of <code>Read Property Map</code>. The vertex descriptor of the input graph <code>G</code> must be usable as a key type for the multi predecessor map. Whereas the value type must satisfy the <code>UnorderedAssociativeContainer</code> concept, where its key is an <code>int</code>, the index/number of alternative path for which it exists a predecessor of <code>v</code>, and where the value type is a vertex descriptor of input graph <code>G</code>. </td></tr>
    <tr><td class="paramname">Vertex</td><td>The vertex descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The input graph. </td></tr>
    <tr><td class="paramname">original_weight</td><td>The weight map of <code>G</code>. </td></tr>
    <tr><td class="paramname">predecessors</td><td>The multi predecessor map of <code>G</code>. </td></tr>
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">k</td><td>The number of alternative paths to compute. </td></tr>
    <tr><td class="paramname">theta</td><td>The similarity threshold. </td></tr>
    <tr><td class="paramname">p</td><td>The penalty factor for edges in the candidate path. </td></tr>
    <tr><td class="paramname">r</td><td>The penalty factor for edges incoming and outgoing to/from vertices of the candidate path. </td></tr>
    <tr><td class="paramname">max_nb_updates</td><td>The maximum number of times an edge can be penalized. </td></tr>
    <tr><td class="paramname">max_nb_steps</td><td>The maximum number of steps of the algorithm (timeout). </td></tr>
    <tr><td class="paramname">algorithm</td><td>The routing kernel to employ. The default is <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11" title="Standard Dijkstra&#39;s Algorithm.">routing_kernels::dijkstra</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad48a2b0626ec88d3de2616204d9d1c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48a2b0626ec88d3de2616204d9d1c1c">&#9670;&nbsp;</a></span>penalty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyGraph , typename MultiPredecessorMap , typename Terminator  = arlib::always_continue, typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::penalty </td>
          <td>(</td>
          <td class="paramtype">const PropertyGraph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiPredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>predecessors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_nb_updates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_nb_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a>&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a754007d2375bb0c609cf387f24fa5b11">routing_kernels::dijkstra</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Terminator &amp;&amp;&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>Terminator{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of Penalty method to compute alternative routes for Boost::Graph. </p>
<p>This overload takes an input graph modeling <code>PropertyGraph</code> concept having at least one edge property with tag <code>boost::edge_weight_t</code>. Moreover it does not require an explicit <code>WeightMap</code> parameter, because it is directly gathered from the <code>PropertyGraph</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacearlib.html#a1720f9aeeba81d08a6b40732d7492bb7" title="An implementation of Penalty method to compute alternative routes for Boost::Graph.">penalty</a>(const Graph &amp;G, WeightMap const &amp;original_weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, double p, double r, int max_nb_updates, int max_nb_steps, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575" title="Routing kernel names in ARLib.">routing_kernels</a> algorithm)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropertyGraph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca11da6d0140c6317a4e9a72a2cc4cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca11da6d0140c6317a4e9a72a2cc4cac">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename Property , typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::put </td>
          <td>(</td>
          <td class="paramtype">Property&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets the property value for <code>k</code> to <code>val</code>. </p>
<p><code>k</code> is either a vertex or edge descriptor. <code>Value</code> must be convertible to <code>typename property_traits&lt;property_map&lt;<a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>&lt;G&gt;, Property&gt;::type&gt;::value_type</code> </p>

</div>
</div>
<a id="a52b1d53ad607d09f8468bf1160922f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b1d53ad607d09f8468bf1160922f03">&#9670;&nbsp;</a></span>read_graph_from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertyGraph arlib::read_graph_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PropertyGraph from vertices, edges and weights contained in a .gr-format string. </p>
<p>An example of .gr-format string is the following: </p><div class="fragment"><div class="line">d</div><div class="line"><span class="preprocessor"># nb_vertices nb_edges</span></div><div class="line">3 2</div><div class="line"><span class="preprocessor"># v1 v2 weight</span></div><div class="line">0 1 4</div><div class="line">1 2 3</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropertyGraph</td><td>The Graph type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A .gr-format string defining the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the constructed graph. </dd></dl>

</div>
</div>
<a id="aeb330378567ebeb6c35d4260ab966132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb330378567ebeb6c35d4260ab966132">&#9670;&nbsp;</a></span>source()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::vertex_descriptor arlib::source </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_descriptor&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The source vertex of edge <code>e</code>. </dd></dl>

</div>
</div>
<a id="a7f7fed81b11f052d5c7a55ac285ebc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7fed81b11f052d5c7a55ac285ebc80">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap between two <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>The graph type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>The second <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71eb5c6f53c6c87f7b8529192e0e5335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eb5c6f53c6c87f7b8529192e0e5335">&#9670;&nbsp;</a></span>target()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::vertex_descriptor arlib::target </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt;::edge_descriptor&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The target vertex of edge <code>e</code>. </dd></dl>

</div>
</div>
<a id="a980037f9960a8321e47f2fb2c9a3e58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980037f9960a8321e47f2fb2c9a3e58d">&#9670;&nbsp;</a></span>to_paths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classarlib_1_1Path.html">Path</a>&lt;Graph&gt; &gt; arlib::to_paths </td>
          <td>(</td>
          <td class="paramtype">Graph const &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sequence of <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a graph <code>G</code> a pair of source-target vertices a <a class="el" href="classarlib_1_1multi__predecessor__map.html" title="The multi predecessor map records the edges in the alternative paths from a pair of source-target ver...">multi_predecessor_map</a> holding alternative paths from <code>s</code> to <code>t</code>. </p>
<p><a class="el" href="classarlib_1_1multi__predecessor__map.html" title="The multi predecessor map records the edges in the alternative paths from a pair of source-target ver...">multi_predecessor_map</a> is often filled by <em>alternative routing</em> algorithms like <a class="el" href="namespacearlib.html#a9bbaf6f6c794b39a8b465c0e24ce1920" title="An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph.">onepass_plus()</a>, <a class="el" href="namespacearlib.html#a20b1e034171566886e8391008e920077" title="An implementation of ESX k-shortest path with limited overlap for Boost::Graph.">esx()</a> or <a class="el" href="namespacearlib.html#a1720f9aeeba81d08a6b40732d7492bb7" title="An implementation of Penalty method to compute alternative routes for Boost::Graph.">penalty()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">pmap</td><td>The multi predecessor map of <code>G</code>. </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence of constructed <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </dd></dl>

</div>
</div>
<a id="a3b12c71af39769d06f27eb9ecd7e894b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b12c71af39769d06f27eb9ecd7e894b">&#9670;&nbsp;</a></span>to_paths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classarlib_1_1Path.html">Path</a>&lt;Graph&gt; &gt; arlib::to_paths </td>
          <td>(</td>
          <td class="paramtype">Graph const &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1multi__predecessor__map.html">multi_predecessor_map</a>&lt; Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sequence of <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a graph <code>G</code> a pair of source-target vertices a <a class="el" href="classarlib_1_1multi__predecessor__map.html" title="The multi predecessor map records the edges in the alternative paths from a pair of source-target ver...">multi_predecessor_map</a> holding alternative paths from <code>s</code> to <code>t</code>. </p>
<p><a class="el" href="classarlib_1_1multi__predecessor__map.html" title="The multi predecessor map records the edges in the alternative paths from a pair of source-target ver...">multi_predecessor_map</a> is often filled by <em>alternative routing</em> algorithms like <a class="el" href="namespacearlib.html#a9bbaf6f6c794b39a8b465c0e24ce1920" title="An implementation of OnePass+ k-shortest path with limited overlap for Boost::Graph.">onepass_plus()</a>, <a class="el" href="namespacearlib.html#a20b1e034171566886e8391008e920077" title="An implementation of ESX k-shortest path with limited overlap for Boost::Graph.">esx()</a> or <a class="el" href="namespacearlib.html#a1720f9aeeba81d08a6b40732d7492bb7" title="An implementation of Penalty method to compute alternative routes for Boost::Graph.">penalty()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A model of a graph for which <code>edge(u, v, G)</code> is a valid expression. </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or "length" of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">pmap</td><td>The multi predecessor map of <code>G</code>. </td></tr>
    <tr><td class="paramname">weight</td><td>The Weight Property Map of <code>G</code>. </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sequence of constructed <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </dd></dl>

</div>
</div>
<a id="a70ddf3055e80291bf2137784d826b501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ddf3055e80291bf2137784d826b501">&#9670;&nbsp;</a></span>uninformed_bidirectional_pruner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename RevWeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PrunedGraph&lt;Graph&gt; arlib::uninformed_bidirectional_pruner </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightMap const &amp;&#160;</td>
          <td class="paramname"><em>weight_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::reverse_graph&lt; Graph &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rev_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RevWeightMap const &amp;&#160;</td>
          <td class="paramname"><em>weight_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of Uninformed Bidirectional Pruning for Boost::Graph. </p>
<p>This implementation refers to the following publication:</p>
<p>Andreas Paraskevopoulos, Christos Zaroliagis. Improved Alternative Route Planning. Daniele Frigioni and Sebastian Stiller. ATMOS - 13th Workshop on Algorithmic Approaches for Transportation Modelling, Optimization, and Systems - 2013, Sep 2013, Sophia Antipolis, France. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 33, pp.108–122, 2013, OpenAccess Series in Informatics (OASIcs).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::VertexAndEdgeListGraph </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or "length" of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
    <tr><td class="paramname">RevWeightMap</td><td>Same as <code>WeightMap</code>, but for <code>boost::reverse_graph&lt;Graph&gt;</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The input graph. </td></tr>
    <tr><td class="paramname">weight_f</td><td>The weight map of <code>G</code>. </td></tr>
    <tr><td class="paramname">rev_G</td><td>A <code>boost::reverse_graph</code> of <code>G</code> </td></tr>
    <tr><td class="paramname">weight_b</td><td>The weight map of <code>rev_G</code>. </td></tr>
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">tau</td><td>The pruning factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pruned copy of <code>G</code>. </dd></dl>

</div>
</div>
<a id="ab73bbe06c2f53c51686902c48db5ab4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73bbe06c2f53c51686902c48db5ab4a">&#9670;&nbsp;</a></span>uninformed_bidirectional_pruner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyGraph , typename Vertex  = vertex_of_t&lt;PropertyGraph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PrunedGraph&lt;PropertyGraph&gt; arlib::uninformed_bidirectional_pruner </td>
          <td>(</td>
          <td class="paramtype">const PropertyGraph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of Uninformed Bidirectional Pruning for Boost::Graph. </p>
<p>This overload takes an input graph modeling <code>PropertyGraph</code> concept having at least one edge property with tag <code>boost::edge_weight_t</code>. Moreover it does not require an explicit <code>WeightMap</code> parameter, because it is directly gathered from the <code>PropertyGraph</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacearlib.html#a70ddf3055e80291bf2137784d826b501" title="An implementation of Uninformed Bidirectional Pruning for Boost::Graph.">uninformed_bidirectional_pruner</a>(const Graph &amp;G, WeightMap const &amp;weight_f, boost::reverse_graph&lt;Graph&gt; const &amp;rev_G, RevWeightMap const &amp;weight_b, Vertex s, Vertex t, double tau)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropertyGraph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pruned copy of <code>G</code>. </dd></dl>

</div>
</div>
<a id="acb7de2abf351c71c8728e4c1a15add11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7de2abf351c71c8728e4c1a15add11">&#9670;&nbsp;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::vertex_iterator, typename <a class="el" href="classarlib_1_1Path.html">Path</a>&lt;G&gt;::vertex_iterator&gt; arlib::vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; G &gt; const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An iterator-range providing access to the vertex set of graph <code>g</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
