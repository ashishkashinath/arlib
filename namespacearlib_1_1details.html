<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARLib: arlib::details Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image/png" href="arlib-logo-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="arlib-logo-32x32.png" sizes="32x32">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arlib-logo-100x100.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ARLib
   </div>
   <div id="projectbrief">An Alternative Route Planning Library for Boost.Graph</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearlib.html">arlib</a></li><li class="navelem"><a class="el" href="namespacearlib_1_1details.html">details</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">arlib::details Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementations details of kSPwLO algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1alternative__path__edges.html">alternative_path_edges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1alternative__path__vertices.html">alternative_path_vertices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1astar__target__visitor.html">astar_target_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An A* visitor to stop the algorithm when a target vertex is found.  <a href="classarlib_1_1details_1_1astar__target__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1distance__heuristic.html">distance_heuristic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An A* heuristic using <em>distance from target</em> lower bound.  <a href="classarlib_1_1details_1_1distance__heuristic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1edge__deleted__filter.html">edge_deleted_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter functor for Boost::filtered_graph to hide edges deleted by ESX.  <a href="classarlib_1_1details_1_1edge__deleted__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1EdgePriorityComparator.html">EdgePriorityComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for edges priority queue.  <a href="structarlib_1_1details_1_1EdgePriorityComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1FringeComparator.html">FringeComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1OnePassLabel.html">OnePassLabel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A label for a node in the graph to keep track of its exploration state.  <a href="classarlib_1_1details_1_1OnePassLabel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1OnePassPlusASComparator.html">OnePassPlusASComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Comparator functor to compare two labels in an A* fashion.  <a href="structarlib_1_1details_1_1OnePassPlusASComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor to return the penalized weight of an edge, to avoid changing the original graph weights.  <a href="classarlib_1_1details_1_1penalty__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1pruned__edges.html">pruned_edges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1reverse__penalty__functor.html">reverse_penalty_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1reverse__weight__functor.html">reverse_weight_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1SkylineContainer.html">SkylineContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conventient container for labels dominance checking.  <a href="classarlib_1_1details_1_1SkylineContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1target__found.html">target_found</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarlib_1_1details_1_1target__not__found.html">target_not_found</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarlib_1_1details_1_1target__visitor.html">target_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ace617814ee15bcb2b6731cbe3cdbe956"><td class="memTemplParams" colspan="2">template&lt;typename Edge &gt; </td></tr>
<tr class="memitem:ace617814ee15bcb2b6731cbe3cdbe956"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#ace617814ee15bcb2b6731cbe3cdbe956">PenBoundsMap</a> = std::unordered_map&lt; Edge, int, boost::hash&lt; Edge &gt; &gt;</td></tr>
<tr class="memdesc:ace617814ee15bcb2b6731cbe3cdbe956"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from edges to the number of time they have been penalized so far.  <a href="#ace617814ee15bcb2b6731cbe3cdbe956">More...</a><br /></td></tr>
<tr class="separator:ace617814ee15bcb2b6731cbe3cdbe956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74e1937db5f6e2f07835bdd80ed2d72"><td class="memTemplParams" colspan="2">template&lt;typename Edge , typename Length &gt; </td></tr>
<tr class="memitem:ab74e1937db5f6e2f07835bdd80ed2d72"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> = std::unordered_map&lt; Edge, Length, boost::hash&lt; Edge &gt; &gt;</td></tr>
<tr class="memdesc:ab74e1937db5f6e2f07835bdd80ed2d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from edges to their weights.  <a href="#ab74e1937db5f6e2f07835bdd80ed2d72">More...</a><br /></td></tr>
<tr class="separator:ab74e1937db5f6e2f07835bdd80ed2d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac533ffdf859998c65d811a09b695d0f1"><td class="memTemplParams" colspan="2">template&lt;typename Length &gt; </td></tr>
<tr class="memitem:ac533ffdf859998c65d811a09b695d0f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> = std::vector&lt; Length &gt;</td></tr>
<tr class="memdesc:ac533ffdf859998c65d811a09b695d0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector for tracking distance of a vertex from the source.  <a href="#ac533ffdf859998c65d811a09b695d0f1">More...</a><br /></td></tr>
<tr class="separator:ac533ffdf859998c65d811a09b695d0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bb56827cc84d3e836bc3345b2f5269"><td class="memTemplParams" colspan="2"><a id="a99bb56827cc84d3e836bc3345b2f5269"></a>
template&lt;typename Vertex &gt; </td></tr>
<tr class="memitem:a99bb56827cc84d3e836bc3345b2f5269"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PathMap</b> = std::unordered_map&lt; Vertex, std::vector&lt; Vertex &gt;, boost::hash&lt; Vertex &gt; &gt;</td></tr>
<tr class="separator:a99bb56827cc84d3e836bc3345b2f5269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011901b8bf725401e286bebee37117a5"><td class="memTemplParams" colspan="2"><a id="a011901b8bf725401e286bebee37117a5"></a>
template&lt;typename Vertex , typename Length &gt; </td></tr>
<tr class="memitem:a011901b8bf725401e286bebee37117a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FringeElem</b> = std::pair&lt; Vertex, Length &gt;</td></tr>
<tr class="separator:a011901b8bf725401e286bebee37117a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd052b54df26535aa32ff5ed5c086ae9"><td class="memTemplParams" colspan="2"><a id="afd052b54df26535aa32ff5ed5c086ae9"></a>
template&lt;typename Vertex , typename Length &gt; </td></tr>
<tr class="memitem:afd052b54df26535aa32ff5ed5c086ae9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Fringe</b> = std::priority_queue&lt; FringeElem&lt; Vertex, Length &gt;, std::vector&lt; FringeElem&lt; Vertex, Length &gt; &gt;, <a class="el" href="structarlib_1_1details_1_1FringeComparator.html">FringeComparator</a>&lt; Vertex, Length &gt; &gt;</td></tr>
<tr class="separator:afd052b54df26535aa32ff5ed5c086ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a5c0dd23df80616865c9bb7b6ca37"><td class="memTemplParams" colspan="2"><a id="a917a5c0dd23df80616865c9bb7b6ca37"></a>
template&lt;typename Vertex , typename Length &gt; </td></tr>
<tr class="memitem:a917a5c0dd23df80616865c9bb7b6ca37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Seen</b> = std::unordered_map&lt; Vertex, Length, boost::hash&lt; Vertex &gt; &gt;</td></tr>
<tr class="separator:a917a5c0dd23df80616865c9bb7b6ca37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab0e3013ce3650ead65afcd6e52dcb232"><td class="memItemLeft" align="right" valign="top"><a id="ab0e3013ce3650ead65afcd6e52dcb232"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#ab0e3013ce3650ead65afcd6e52dcb232">Direction</a> { <b>forward</b> = 1, 
<b>backward</b>
 }</td></tr>
<tr class="memdesc:ab0e3013ce3650ead65afcd6e52dcb232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to describe whether a forward or a backward step of bidirectional dijkstra is executing. <br /></td></tr>
<tr class="separator:ab0e3013ce3650ead65afcd6e52dcb232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6981071b444a86195115b5299574e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9">BiDijkStepRes</a> { <a class="el" href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9ad0cab90d8d20d57e2f2b9be52f7dd25d">BiDijkStepRes::next</a> = 1, 
<a class="el" href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9a7f021a1415b86f2d013b2618fb31ae53">BiDijkStepRes::end</a>, 
<a class="el" href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9ad328ca7b3ba9c108efa5adf12a501f5f">BiDijkStepRes::negative_weights</a>
 }</td></tr>
<tr class="memdesc:a5f6981071b444a86195115b5299574e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return code of bi_dijkstra_step()  <a href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9">More...</a><br /></td></tr>
<tr class="separator:a5f6981071b444a86195115b5299574e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a869ab609df012df3661789d78194ccd9"><td class="memTemplParams" colspan="2"><a id="a869ab609df012df3661789d78194ccd9"></a>
template&lt;typename Vertex , typename Tag &gt; </td></tr>
<tr class="memitem:a869ab609df012df3661789d78194ccd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1details_1_1target__visitor.html">target_visitor</a>&lt; Vertex, Tag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_target_visitor</b> (Vertex t, Tag)</td></tr>
<tr class="separator:a869ab609df012df3661789d78194ccd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ead4f0f469fadbb9cdcc01f35aaf34"><td class="memTemplParams" colspan="2"><a id="ae5ead4f0f469fadbb9cdcc01f35aaf34"></a>
template&lt;typename CostType , typename Vertex , typename DistMap &gt; </td></tr>
<tr class="memitem:ae5ead4f0f469fadbb9cdcc01f35aaf34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exists_path_to</b> (Vertex v, const DistMap &amp;dist)</td></tr>
<tr class="separator:ae5ead4f0f469fadbb9cdcc01f35aaf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127a57ee19f9bf85aa121cd6f55441a4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename GWeightMap , typename Length  = value_of_t&lt;GWeightMap&gt;&gt; </td></tr>
<tr class="memitem:a127a57ee19f9bf85aa121cd6f55441a4"><td class="memTemplItemLeft" align="right" valign="top">Length&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a127a57ee19f9bf85aa121cd6f55441a4">compute_length_from_edges</a> (ForwardIt first, ForwardIt last, GWeightMap const &amp;weight)</td></tr>
<tr class="memdesc:a127a57ee19f9bf85aa121cd6f55441a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the length of the path in <code>candidate</code> using weights from <code>G</code>.  <a href="#a127a57ee19f9bf85aa121cd6f55441a4">More...</a><br /></td></tr>
<tr class="separator:a127a57ee19f9bf85aa121cd6f55441a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8230b5d2ae8a2476dca2847b85132"><td class="memTemplParams" colspan="2"><a id="a14e8230b5d2ae8a2476dca2847b85132"></a>
template&lt;typename GWeightMap , typename Edge , typename Length  = value_of_t&lt;GWeightMap&gt;&gt; </td></tr>
<tr class="memitem:a14e8230b5d2ae8a2476dca2847b85132"><td class="memTemplItemLeft" align="right" valign="top">Length&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_shared_length</b> (const std::vector&lt; Edge &gt; &amp;candidate, std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt; const &amp;alt_path, GWeightMap const &amp;weight)</td></tr>
<tr class="separator:a14e8230b5d2ae8a2476dca2847b85132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3efa8230d35c759dd8b178dc7d4d62"><td class="memTemplParams" colspan="2"><a id="a7b3efa8230d35c759dd8b178dc7d4d62"></a>
template&lt;typename Graph , typename GWeightMap , typename Length  = value_of_t&lt;GWeightMap&gt;&gt; </td></tr>
<tr class="memitem:a7b3efa8230d35c759dd8b178dc7d4d62"><td class="memTemplItemLeft" align="right" valign="top">Length&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_shared_length</b> (const Graph &amp;candidate, const Graph &amp;G, GWeightMap const &amp;weight)</td></tr>
<tr class="separator:a7b3efa8230d35c759dd8b178dc7d4d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510b48962797d775410b10142402e5b0"><td class="memTemplParams" colspan="2"><a id="a510b48962797d775410b10142402e5b0"></a>
template&lt;typename Edge , typename AltEdgeWeightMap &gt; </td></tr>
<tr class="memitem:a510b48962797d775410b10142402e5b0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_similarity</b> (const std::vector&lt; Edge &gt; &amp;candidate, const std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt; &amp;alt_path, AltEdgeWeightMap const &amp;weight)</td></tr>
<tr class="separator:a510b48962797d775410b10142402e5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21701de2dcf7b8671cdede7a3d6573"><td class="memTemplParams" colspan="2"><a id="a1f21701de2dcf7b8671cdede7a3d6573"></a>
template&lt;typename Graph , typename AltEdgeWeightMap &gt; </td></tr>
<tr class="memitem:a1f21701de2dcf7b8671cdede7a3d6573"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_similarity</b> (const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &amp;candidate, const <a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt; &amp;alt_path, AltEdgeWeightMap const &amp;weight)</td></tr>
<tr class="separator:a1f21701de2dcf7b8671cdede7a3d6573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dc524e1d331109e694f64dfad3b15b"><td class="memTemplParams" colspan="2"><a id="a38dc524e1d331109e694f64dfad3b15b"></a>
template&lt;typename Length , typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a38dc524e1d331109e694f64dfad3b15b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Length &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance_from_target</b> (const Graph &amp;G, Vertex t)</td></tr>
<tr class="separator:a38dc524e1d331109e694f64dfad3b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafed81a0b3cf6157484d01c0d459d77a"><td class="memTemplParams" colspan="2"><a id="aafed81a0b3cf6157484d01c0d459d77a"></a>
template&lt;typename Graph , typename EdgeWeightMap , typename PredecessorMap , typename Vertex &gt; </td></tr>
<tr class="memitem:aafed81a0b3cf6157484d01c0d459d77a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_path_from_dijkstra</b> (const Graph &amp;G, EdgeWeightMap const &amp;weight, const PredecessorMap &amp;p, Vertex s, Vertex t)</td></tr>
<tr class="separator:aafed81a0b3cf6157484d01c0d459d77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35113696f3c3f449de4c36628050298c"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PredecessorMap , typename Edge  = edge_of_t&lt;Graph&gt;, typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a35113696f3c3f449de4c36628050298c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Edge &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a35113696f3c3f449de4c36628050298c">build_edge_list_from_dijkstra</a> (Graph const &amp;G, Vertex s, Vertex t, const PredecessorMap &amp;p)</td></tr>
<tr class="memdesc:a35113696f3c3f449de4c36628050298c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a vector of kspwlo::Edge out of a PredecessorMap computed by a shortest path algorithm from <code>s</code> to <code>t</code>.  <a href="#a35113696f3c3f449de4c36628050298c">More...</a><br /></td></tr>
<tr class="separator:a35113696f3c3f449de4c36628050298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8069d7dd614925a928911197c581d8"><td class="memTemplParams" colspan="2"><a id="aac8069d7dd614925a928911197c581d8"></a>
template&lt;typename Graph , typename EdgeWeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = value_of_t&lt;EdgeWeightMap&gt;&gt; </td></tr>
<tr class="memitem:aac8069d7dd614925a928911197c581d8"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_shortest_path</b> (const Graph &amp;G, EdgeWeightMap const &amp;weight, Vertex s, Vertex t)</td></tr>
<tr class="separator:aac8069d7dd614925a928911197c581d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e49ff3d3a5d39b25eb347e6a12d4615"><td class="memTemplParams" colspan="2"><a id="a2e49ff3d3a5d39b25eb347e6a12d4615"></a>
template&lt;typename ForwardIt , typename Graph , typename MultiPredecessorMap &gt; </td></tr>
<tr class="memitem:a2e49ff3d3a5d39b25eb347e6a12d4615"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_multi_predecessor</b> (ForwardIt first, ForwardIt last, Graph const &amp;G, MultiPredecessorMap &amp;pmap)</td></tr>
<tr class="separator:a2e49ff3d3a5d39b25eb347e6a12d4615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317cc8632710c8359abe8d76016f5ed6"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PredMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a317cc8632710c8359abe8d76016f5ed6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a317cc8632710c8359abe8d76016f5ed6">shortest_path_contains_edge</a> (Vertex s, Vertex t, Edge e, const Graph &amp;G, const PredMap &amp;predecessor)</td></tr>
<tr class="memdesc:a317cc8632710c8359abe8d76016f5ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the path from <code>s</code> to <code>t</code> contains edge <code>e</code> or not.  <a href="#a317cc8632710c8359abe8d76016f5ed6">More...</a><br /></td></tr>
<tr class="separator:a317cc8632710c8359abe8d76016f5ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb50f2047603bcc8a2cbf486da2b137"><td class="memTemplParams" colspan="2"><a id="aeeb50f2047603bcc8a2cbf486da2b137"></a>
template&lt;typename Graph , typename WeightMap , typename DeletedEdgeMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:aeeb50f2047603bcc8a2cbf486da2b137"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dijkstra_shortest_path</b> (const Graph &amp;G, Vertex s, Vertex t, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, DeletedEdgeMap &amp;deleted_edge_map)</td></tr>
<tr class="separator:aeeb50f2047603bcc8a2cbf486da2b137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0373cc347db5812e02845b33b5b2208"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename AStarHeuristic , typename DeletedEdgeMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:ab0373cc347db5812e02845b33b5b2208"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#ab0373cc347db5812e02845b33b5b2208">astar_shortest_path</a> (const Graph &amp;G, Vertex s, Vertex t, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, const AStarHeuristic &amp;heuristic, DeletedEdgeMap &amp;deleted_edge_map)</td></tr>
<tr class="memdesc:ab0373cc347db5812e02845b33b5b2208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a shortest path between two vertices on a filtered graph using an A* approach, provided the set of edges to filter and the heuristic.  <a href="#ab0373cc347db5812e02845b33b5b2208">More...</a><br /></td></tr>
<tr class="separator:ab0373cc347db5812e02845b33b5b2208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efa1ae7819d9a5c66e73f23445f7481"><td class="memTemplParams" colspan="2"><a id="a5efa1ae7819d9a5c66e73f23445f7481"></a>
template&lt;typename Graph , typename WeightMap , typename DeletedEdgeMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a5efa1ae7819d9a5c66e73f23445f7481"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bidirectional_dijkstra_shortest_path</b> (const Graph &amp;G, Vertex s, Vertex t, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, DeletedEdgeMap &amp;deleted_edge_map)</td></tr>
<tr class="separator:a5efa1ae7819d9a5c66e73f23445f7481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72bd3ed159a4d14b2902b46ab2bb426"><td class="memTemplParams" colspan="2"><a id="ac72bd3ed159a4d14b2902b46ab2bb426"></a>
template&lt;typename Graph , typename WeightMap , typename AStarHeuristic , typename DeletedEdgeMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:ac72bd3ed159a4d14b2902b46ab2bb426"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::function&lt; std::optional&lt; std::vector&lt; Edge &gt; &gt; const Graph &amp;, Vertex, Vertex, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;, DeletedEdgeMap &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shortest_path_fn</b> (<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, const Graph &amp;, Vertex, Vertex, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;, const AStarHeuristic &amp;heuristic, DeletedEdgeMap &amp;)</td></tr>
<tr class="separator:ac72bd3ed159a4d14b2902b46ab2bb426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea924094939b074049fddcd84906d08"><td class="memTemplParams" colspan="2"><a id="a8ea924094939b074049fddcd84906d08"></a>
template&lt;typename Graph , typename WeightMap , typename DeletedEdgeMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a8ea924094939b074049fddcd84906d08"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::function&lt; std::optional&lt; std::vector&lt; Edge &gt; &gt; const Graph &amp;, Vertex, Vertex, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;, DeletedEdgeMap &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shortest_path_fn</b> (<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, const Graph &amp;, Vertex, Vertex, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;, DeletedEdgeMap &amp;)</td></tr>
<tr class="separator:a8ea924094939b074049fddcd84906d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1059517067126adfcbad34dd8acac5c0"><td class="memTemplParams" colspan="2"><a id="a1059517067126adfcbad34dd8acac5c0"></a>
template&lt;typename Graph2 , typename Length2 &gt; </td></tr>
<tr class="memitem:a1059517067126adfcbad34dd8acac5c0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classarlib_1_1details_1_1OnePassLabel.html">OnePassLabel</a>&lt; Graph2, Length2 &gt; &amp;label)</td></tr>
<tr class="separator:a1059517067126adfcbad34dd8acac5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ca30f9d1cb1cedd0e453faf4479c84"><td class="memTemplParams" colspan="2"><a id="a94ca30f9d1cb1cedd0e453faf4479c84"></a>
template&lt;typename Graph , typename EdgeMap , typename resPathIndex  = typename EdgeMap::mapped_type::size_type&gt; </td></tr>
<tr class="memitem:a94ca30f9d1cb1cedd0e453faf4479c84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>update_res_edges</b> (const Graph &amp;candidate, const Graph &amp;graph, EdgeMap &amp;resEdges, resPathIndex paths_count)</td></tr>
<tr class="separator:a94ca30f9d1cb1cedd0e453faf4479c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54da4aa3573ccdabd1905edc2a00f66c"><td class="memTemplParams" colspan="2"><a id="a54da4aa3573ccdabd1905edc2a00f66c"></a>
template&lt;typename EdgeMap , typename Edge , typename resPathIndex  = typename EdgeMap::mapped_type::size_type&gt; </td></tr>
<tr class="memitem:a54da4aa3573ccdabd1905edc2a00f66c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>update_res_edges</b> (const std::vector&lt; Edge &gt; &amp;candidate, EdgeMap &amp;resEdges, resPathIndex paths_count)</td></tr>
<tr class="separator:a54da4aa3573ccdabd1905edc2a00f66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e767a5e5851711f08907289a519dba"><td class="memTemplParams" colspan="2"><a id="a74e767a5e5851711f08907289a519dba"></a>
template&lt;typename Label , typename Graph , typename EdgesMap , typename PathsMap , typename WeightMap &gt; </td></tr>
<tr class="memitem:a74e767a5e5851711f08907289a519dba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>update_label_similarity</b> (Label &amp;label, const Graph &amp;G, const EdgesMap &amp;resEdges, const PathsMap &amp;resPaths, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, double theta, std::size_t step)</td></tr>
<tr class="separator:a74e767a5e5851711f08907289a519dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0cadf871a50019ea09960a44bdd0fa"><td class="memTemplParams" colspan="2"><a id="aef0cadf871a50019ea09960a44bdd0fa"></a>
template&lt;typename Label , typename Vertex  = typename Label::Vertex, typename length_type  = typename Label::length_type&gt; </td></tr>
<tr class="memitem:aef0cadf871a50019ea09960a44bdd0fa"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Label &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>expand_path</b> (Label *label, Vertex node, length_type node_lower_bound, length_type edge_weight, int step)</td></tr>
<tr class="separator:aef0cadf871a50019ea09960a44bdd0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ed826f9914049d39ecceefcd3febf"><td class="memTemplParams" colspan="2"><a id="a175ed826f9914049d39ecceefcd3febf"></a>
template&lt;typename EdgesMap , typename PathsList , typename WeightMap , typename Edge  = typename EdgesMap::key_type&gt; </td></tr>
<tr class="memitem:a175ed826f9914049d39ecceefcd3febf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_below_sim_threshold</b> (const Edge &amp;c_edge, std::vector&lt; double &gt; &amp;similarity_map, double theta, const EdgesMap &amp;resEdges, const PathsList &amp;resPaths, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight)</td></tr>
<tr class="separator:a175ed826f9914049d39ecceefcd3febf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5190c73a0840b9e58be99cbcc7ad485c"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a5190c73a0840b9e58be99cbcc7ad485c"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a5190c73a0840b9e58be99cbcc7ad485c">dijkstra_shortest_path_two_ways</a> (const Graph &amp;G, Vertex s, Vertex t, <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a>&lt; Length &gt; &amp;distance_s, <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a>&lt; Length &gt; &amp;distance_t)</td></tr>
<tr class="memdesc:a5190c73a0840b9e58be99cbcc7ad485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shortest path between two vertices s and t, first from s to t and then from t to s.  <a href="#a5190c73a0840b9e58be99cbcc7ad485c">More...</a><br /></td></tr>
<tr class="separator:a5190c73a0840b9e58be99cbcc7ad485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c851f670287cae9d45545d2d84e0a8"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a84c851f670287cae9d45545d2d84e0a8"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a84c851f670287cae9d45545d2d84e0a8">dijkstra_shortest_path</a> (const Graph &amp;G, Vertex s, Vertex t, <a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;penalty)</td></tr>
<tr class="memdesc:a84c851f670287cae9d45545d2d84e0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Dijkstra shortest path from s to t using a <a class="el" href="classarlib_1_1details_1_1penalty__functor.html" title="A functor to return the penalized weight of an edge, to avoid changing the original graph weights.">penalty_functor</a> to gather edges weight instead of the Graph's weight property map.  <a href="#a84c851f670287cae9d45545d2d84e0a8">More...</a><br /></td></tr>
<tr class="separator:a84c851f670287cae9d45545d2d84e0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab0de7db2f4972d1f1fccecf81b5d57"><td class="memTemplParams" colspan="2"><a id="aaab0de7db2f4972d1f1fccecf81b5d57"></a>
template&lt;typename Graph , typename PMap , typename AStarHeuristic , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:aaab0de7db2f4972d1f1fccecf81b5d57"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>astar_shortest_path</b> (const Graph &amp;G, Vertex s, Vertex t, <a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;penalty, const AStarHeuristic &amp;heuristic)</td></tr>
<tr class="separator:aaab0de7db2f4972d1f1fccecf81b5d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b188af57073671ba21ab5ce9fb822e"><td class="memTemplParams" colspan="2"><a id="a58b188af57073671ba21ab5ce9fb822e"></a>
template&lt;typename Graph , typename PMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a58b188af57073671ba21ab5ce9fb822e"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Edge &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bidirectional_dijkstra_shortest_path</b> (const Graph &amp;G, Vertex s, Vertex t, <a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;penalty)</td></tr>
<tr class="separator:a58b188af57073671ba21ab5ce9fb822e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba34e823605d080d037e5c06a16228e"><td class="memTemplParams" colspan="2"><a id="a5ba34e823605d080d037e5c06a16228e"></a>
template&lt;typename Graph , typename PMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a5ba34e823605d080d037e5c06a16228e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::function&lt; std::optional&lt; std::vector&lt; Edge &gt; &gt; const Graph &amp;, Vertex, Vertex, <a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shortest_path_fn</b> (<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, const Graph &amp;, const PMap &amp;)</td></tr>
<tr class="separator:a5ba34e823605d080d037e5c06a16228e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80366d976068df7a330caa766b8176e9"><td class="memTemplParams" colspan="2"><a id="a80366d976068df7a330caa766b8176e9"></a>
template&lt;typename Graph , typename PMap , typename AStarHeuristic , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a80366d976068df7a330caa766b8176e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::function&lt; std::optional&lt; std::vector&lt; Edge &gt; &gt; const Graph &amp;, Vertex, Vertex, <a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>build_shortest_path_fn</b> (<a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, const Graph &amp;, const PMap &amp;, const AStarHeuristic &amp;heuristic)</td></tr>
<tr class="separator:a80366d976068df7a330caa766b8176e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dca603b96ef5d69a5f35dfda5fb5ec4"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename DistanceMap , typename PMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a3dca603b96ef5d69a5f35dfda5fb5ec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a3dca603b96ef5d69a5f35dfda5fb5ec4">penalize_candidate_path</a> (const std::vector&lt; Edge &gt; &amp;candidate, const Graph &amp;G, Vertex s, Vertex t, double p, double r, <a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;penalty, const <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> &amp;distance_s, const <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> &amp;distance_t, <a class="el" href="namespacearlib_1_1details.html#ace617814ee15bcb2b6731cbe3cdbe956">PenBoundsMap</a>&lt; Edge &gt; &amp;penalty_bounds, int bound_limit)</td></tr>
<tr class="memdesc:a3dca603b96ef5d69a5f35dfda5fb5ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply penalization step to the candidate path.  <a href="#a3dca603b96ef5d69a5f35dfda5fb5ec4">More...</a><br /></td></tr>
<tr class="separator:a3dca603b96ef5d69a5f35dfda5fb5ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c934df520df83ae0de0cac766cba80"><td class="memTemplParams" colspan="2"><a id="a03c934df520df83ae0de0cac766cba80"></a>
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename RoutingKernel , typename Terminator , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a03c934df520df83ae0de0cac766cba80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>penalty</b> (const Graph &amp;G, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;original_weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, double p, double r, int max_nb_updates, int max_nb_steps, RoutingKernel &amp;routing_kernel, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>)</td></tr>
<tr class="separator:a03c934df520df83ae0de0cac766cba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8582e7b5b02a86d814d20d77972fcd5"><td class="memTemplParams" colspan="2"><a id="aa8582e7b5b02a86d814d20d77972fcd5"></a>
template&lt;typename Vertex , typename FPredecessorMap , typename BPredecessorMap , typename FDistanceMap , typename BDistanceMap , typename Length &gt; </td></tr>
<tr class="memitem:aa8582e7b5b02a86d814d20d77972fcd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pruning_policy</b> (Vertex s, Vertex t, Vertex v, FPredecessorMap predecessor_f, BPredecessorMap predecessor_b, FDistanceMap distance_f, BDistanceMap distance_b, double tau, Length final_distance)</td></tr>
<tr class="separator:aa8582e7b5b02a86d814d20d77972fcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a24d7e2f264023bb7309e932fe14d86"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a3a24d7e2f264023bb7309e932fe14d86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a3a24d7e2f264023bb7309e932fe14d86">build_path_from</a> (std::vector&lt; Vertex &gt; const &amp;path, Graph const &amp;G, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;W)</td></tr>
<tr class="memdesc:a3a24d7e2f264023bb7309e932fe14d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a sequence of vertices of a graph <code>G</code>.  <a href="#a3a24d7e2f264023bb7309e932fe14d86">More...</a><br /></td></tr>
<tr class="separator:a3a24d7e2f264023bb7309e932fe14d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c4c3482d63557fcfc6a5748caa7f09"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a02c4c3482d63557fcfc6a5748caa7f09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt; Graph &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a02c4c3482d63557fcfc6a5748caa7f09">build_path_from</a> (std::vector&lt; Vertex &gt; const &amp;path, Graph const &amp;G)</td></tr>
<tr class="memdesc:a02c4c3482d63557fcfc6a5748caa7f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a sequence of vertices of a graph <code>G</code>.  <a href="#a02c4c3482d63557fcfc6a5748caa7f09">More...</a><br /></td></tr>
<tr class="separator:a02c4c3482d63557fcfc6a5748caa7f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615cd3e0b8399e420c9618c0b74153d1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacearlib_1_1details.html#ab0e3013ce3650ead65afcd6e52dcb232">Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a615cd3e0b8399e420c9618c0b74153d1">switch_direction</a> (<a class="el" href="namespacearlib_1_1details.html#ab0e3013ce3650ead65afcd6e52dcb232">Direction</a> prev_dir)</td></tr>
<tr class="memdesc:a615cd3e0b8399e420c9618c0b74153d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the opposite direction.  <a href="#a615cd3e0b8399e420c9618c0b74153d1">More...</a><br /></td></tr>
<tr class="separator:a615cd3e0b8399e420c9618c0b74153d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a2bf0bdc7b17c10ba193d919cea238"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename DistanceMap &gt; </td></tr>
<tr class="memitem:a15a2bf0bdc7b17c10ba193d919cea238"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a15a2bf0bdc7b17c10ba193d919cea238">init_distance_vector</a> (Graph &amp;G, <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> distance)</td></tr>
<tr class="memdesc:a15a2bf0bdc7b17c10ba193d919cea238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a DistanceMap with <code>infinite</code> value for each vertex in the graph.  <a href="#a15a2bf0bdc7b17c10ba193d919cea238">More...</a><br /></td></tr>
<tr class="separator:a15a2bf0bdc7b17c10ba193d919cea238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b734ef82f695f1eb3ed4101312ce665"><td class="memTemplParams" colspan="2"><a id="a7b734ef82f695f1eb3ed4101312ce665"></a>
template&lt;typename Vertex , typename PredecessorMap , typename BackPredecessorMap &gt; </td></tr>
<tr class="memitem:a7b734ef82f695f1eb3ed4101312ce665"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge_paths</b> (Vertex s, Vertex t, Vertex w, PredecessorMap predecessor_f, BackPredecessorMap predecessor_b, std::deque&lt; Vertex &gt; &amp;final_path)</td></tr>
<tr class="separator:a7b734ef82f695f1eb3ed4101312ce665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb72fb27906cc098c8b61f53c27b264"><td class="memTemplParams" colspan="2"><a id="a3cb72fb27906cc098c8b61f53c27b264"></a>
template&lt;typename Vertex , typename Length , typename PredecessorMap , typename BackPredecessorMap &gt; </td></tr>
<tr class="memitem:a3cb72fb27906cc098c8b61f53c27b264"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compare_and_update_shortest_path</b> (Seen&lt; Vertex, Length &gt; &amp;seen_f, Seen&lt; Vertex, Length &gt; &amp;seen_b, PredecessorMap predecessor_f, BackPredecessorMap predecessor_b, Vertex s, Vertex t, Vertex w, Length &amp;final_distance, std::deque&lt; Vertex &gt; &amp;final_path)</td></tr>
<tr class="separator:a3cb72fb27906cc098c8b61f53c27b264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a5b8bd620e46ac790c9d6c719276a3"><td class="memTemplParams" colspan="2"><a id="a92a5b8bd620e46ac790c9d6c719276a3"></a>
template&lt;typename Graph , typename PredecessorMap , typename DistanceMap , typename WeightMap , typename OtherPredecessorMap , typename OtherDistanceMap , typename BiDijkstraVisitorImpl , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Length  = value_of_t&lt;DistanceMap&gt;&gt; </td></tr>
<tr class="memitem:a92a5b8bd620e46ac790c9d6c719276a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9">BiDijkStepRes</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bi_dijkstra_step</b> (const Graph &amp;G, Vertex s, Vertex t, PredecessorMap predecessor, <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> distance, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> weight, Fringe&lt; Vertex, Length &gt; &amp;fringe, Seen&lt; Vertex, Length &gt; &amp;seen, OtherPredecessorMap other_predecessor, OtherDistanceMap other_distance, Fringe&lt; Vertex, Length &gt; &amp;other_fringe, Seen&lt; Vertex, Length &gt; &amp;other_seen, <a class="el" href="namespacearlib_1_1details.html#ab0e3013ce3650ead65afcd6e52dcb232">Direction</a> direction, Length &amp;final_distance, std::deque&lt; Vertex &gt; &amp;final_path, <a class="el" href="classarlib_1_1BiDijkstraVisitor.html">BiDijkstraVisitor</a>&lt; BiDijkstraVisitorImpl &gt; &amp;visitor)</td></tr>
<tr class="separator:a92a5b8bd620e46ac790c9d6c719276a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff1a9af30844f7a6fd0b87cf878d34c"><td class="memTemplParams" colspan="2"><a id="aaff1a9af30844f7a6fd0b87cf878d34c"></a>
template&lt;typename PredecessorMap , typename Vertex &gt; </td></tr>
<tr class="memitem:aaff1a9af30844f7a6fd0b87cf878d34c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_predecessor</b> (PredecessorMap predecessor, const std::deque&lt; Vertex &gt; &amp;final_path)</td></tr>
<tr class="separator:aaff1a9af30844f7a6fd0b87cf878d34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adaa333b32bc9ab626594b7c1f7291c25"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename WeightMap , typename DeletedEdgeMap , typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:adaa333b32bc9ab626594b7c1f7291c25"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#adaa333b32bc9ab626594b7c1f7291c25">compute_priority</a> (const Graph &amp;G, const Edge &amp;e, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, const DeletedEdgeMap &amp;deleted_edge_map)</td></tr>
<tr class="memdesc:adaa333b32bc9ab626594b7c1f7291c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ESX priority of an edge.  <a href="#adaa333b32bc9ab626594b7c1f7291c25">More...</a><br /></td></tr>
<tr class="separator:adaa333b32bc9ab626594b7c1f7291c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee7d22ebb6f057f95cad08c14637e2b"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename PrioritiesVector , typename WeightMap , typename EdgeMap , typename Index  = typename PrioritiesVector::size_type&gt; </td></tr>
<tr class="memitem:abee7d22ebb6f057f95cad08c14637e2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#abee7d22ebb6f057f95cad08c14637e2b">init_edge_priorities</a> (const Graph &amp;alternative, PrioritiesVector &amp;edge_priorities, Index alt_index, const Graph &amp;G, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, const EdgeMap &amp;deleted_edges)</td></tr>
<tr class="memdesc:abee7d22ebb6f057f95cad08c14637e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the edge priorities of an alternative path.  <a href="#abee7d22ebb6f057f95cad08c14637e2b">More...</a><br /></td></tr>
<tr class="separator:abee7d22ebb6f057f95cad08c14637e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413fa4118e821f61452f393ffe56333d"><td class="memTemplParams" colspan="2">template&lt;typename PrioritiesVector , typename Graph , typename WeightMap , typename EdgeMap , typename Edge  = edge_of_t&lt;Graph&gt;, typename Index  = typename PrioritiesVector::size_type&gt; </td></tr>
<tr class="memitem:a413fa4118e821f61452f393ffe56333d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a413fa4118e821f61452f393ffe56333d">init_edge_priorities</a> (const std::vector&lt; Edge &gt; &amp;alternative, PrioritiesVector &amp;edge_priorities, Index alt_index, const Graph &amp;G, const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;weight, const EdgeMap &amp;deleted_edges)</td></tr>
<tr class="memdesc:a413fa4118e821f61452f393ffe56333d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the edge priorities of an alternative path.  <a href="#a413fa4118e821f61452f393ffe56333d">More...</a><br /></td></tr>
<tr class="separator:a413fa4118e821f61452f393ffe56333d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941daa4e279f920870bef6757c54d5b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a941daa4e279f920870bef6757c54d5b7">check_feasibility</a> (const std::vector&lt; double &gt; &amp;overlaps)</td></tr>
<tr class="memdesc:a941daa4e279f920870bef6757c54d5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether another alternative path can be found by ESX.  <a href="#a941daa4e279f920870bef6757c54d5b7">More...</a><br /></td></tr>
<tr class="separator:a941daa4e279f920870bef6757c54d5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9097e64acb35fcb19c9c435d0e264ec1"><td class="memTemplParams" colspan="2">template&lt;typename Edge , typename WeightMap &gt; </td></tr>
<tr class="memitem:a9097e64acb35fcb19c9c435d0e264ec1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearlib_1_1details.html#a9097e64acb35fcb19c9c435d0e264ec1">check_candidate_validity</a> (const std::vector&lt; Edge &gt; &amp;candidate, const std::vector&lt; std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt;&gt; &amp;alternatives, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;weight, double theta)</td></tr>
<tr class="memdesc:a9097e64acb35fcb19c9c435d0e264ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a candidate path satisfies the condition to add it the the alternative paths set.  <a href="#a9097e64acb35fcb19c9c435d0e264ec1">More...</a><br /></td></tr>
<tr class="separator:a9097e64acb35fcb19c9c435d0e264ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f913c5358b8d9316e3596c45339030"><td class="memTemplParams" colspan="2"><a id="ac9f913c5358b8d9316e3596c45339030"></a>
template&lt;typename Edge &gt; </td></tr>
<tr class="memitem:ac9f913c5358b8d9316e3596c45339030"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_to_dnr</b> (Edge e, std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt; &amp;deleted_edges, std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt; &amp;dnr_edges)</td></tr>
<tr class="separator:ac9f913c5358b8d9316e3596c45339030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02eb584691b76cd8554805414b44be3"><td class="memTemplParams" colspan="2"><a id="ae02eb584691b76cd8554805414b44be3"></a>
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename PriorityFunc , typename RoutingKernel , typename Terminator , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:ae02eb584691b76cd8554805414b44be3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>esx</b> (const Graph &amp;G, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, PriorityFunc &amp;&amp;priority_fn, RoutingKernel &amp;routing_kernel, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>)</td></tr>
<tr class="separator:ae02eb584691b76cd8554805414b44be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6aea52a3b451af5d57bbd5c06b2cb"><td class="memTemplParams" colspan="2"><a id="a73d6aea52a3b451af5d57bbd5c06b2cb"></a>
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename PriorityFunc , typename Terminator , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a73d6aea52a3b451af5d57bbd5c06b2cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>esx_dispatch2</b> (const Graph &amp;G, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, PriorityFunc &amp;&amp;priority_fn, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>)</td></tr>
<tr class="separator:a73d6aea52a3b451af5d57bbd5c06b2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2243639935c6875dfb84b7d0227674c7"><td class="memTemplParams" colspan="2"><a id="a2243639935c6875dfb84b7d0227674c7"></a>
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename Terminator , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a2243639935c6875dfb84b7d0227674c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>esx_dispatch</b> (const Graph &amp;G, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;weight, MultiPredecessorMap &amp;predecessors, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>)</td></tr>
<tr class="separator:a2243639935c6875dfb84b7d0227674c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170bc5e5de4fdb188837a6e704f63f76"><td class="memTemplParams" colspan="2"><a id="a170bc5e5de4fdb188837a6e704f63f76"></a>
template&lt;typename Graph , typename WeightMap , typename MultiPredecessorMap , typename EdgeCentralityMap , typename Terminator , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </td></tr>
<tr class="memitem:a170bc5e5de4fdb188837a6e704f63f76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>esx_dispatch</b> (const Graph &amp;G, <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;weight, MultiPredecessorMap &amp;predecessors, EdgeCentralityMap const &amp;edge_centrality, Vertex s, Vertex t, int k, double theta, <a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575">routing_kernels</a> algorithm, Terminator &amp;&amp;<a class="el" href="structarlib_1_1terminator.html">terminator</a>)</td></tr>
<tr class="separator:a170bc5e5de4fdb188837a6e704f63f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementations details of kSPwLO algorithms. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac533ffdf859998c65d811a09b695d0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac533ffdf859998c65d811a09b695d0f1">&#9670;&nbsp;</a></span>DistanceMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Length &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">arlib::details::DistanceMap</a> = typedef std::vector&lt;Length&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector for tracking distance of a vertex from the source. </p>
<p>The vector must be indexable by the vertex_descriptor, thus its size should be equal to the number of vertices in the graph.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Length</td><td>The edge weight type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace617814ee15bcb2b6731cbe3cdbe956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace617814ee15bcb2b6731cbe3cdbe956">&#9670;&nbsp;</a></span>PenBoundsMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Edge &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib_1_1details.html#ace617814ee15bcb2b6731cbe3cdbe956">arlib::details::PenBoundsMap</a> = typedef std::unordered_map&lt;Edge, int, boost::hash&lt;Edge&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from edges to the number of time they have been penalized so far. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Edge</td><td>An edge_descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74e1937db5f6e2f07835bdd80ed2d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74e1937db5f6e2f07835bdd80ed2d72">&#9670;&nbsp;</a></span>WeightMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Edge , typename Length &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">arlib::details::WeightMap</a> = typedef std::unordered_map&lt;Edge, Length, boost::hash&lt;Edge&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from edges to their weights. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Edge</td><td>An edge_descriptor </td></tr>
    <tr><td class="paramname">Length</td><td>The edge weight type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5f6981071b444a86195115b5299574e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6981071b444a86195115b5299574e9">&#9670;&nbsp;</a></span>BiDijkStepRes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearlib_1_1details.html#a5f6981071b444a86195115b5299574e9">arlib::details::BiDijkStepRes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return code of bi_dijkstra_step() </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f6981071b444a86195115b5299574e9ad0cab90d8d20d57e2f2b9be52f7dd25d"></a>next&#160;</td><td class="fielddoc"><p><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a88897dfad3fa724d035439daed14b098" title="bidirectional_dijkstra()">arlib::bidirectional_dijkstra()</a> should execute another step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f6981071b444a86195115b5299574e9a7f021a1415b86f2d013b2618fb31ae53"></a>end&#160;</td><td class="fielddoc"><p><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a88897dfad3fa724d035439daed14b098" title="bidirectional_dijkstra()">arlib::bidirectional_dijkstra()</a> should end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f6981071b444a86195115b5299574e9ad328ca7b3ba9c108efa5adf12a501f5f"></a>negative_weights&#160;</td><td class="fielddoc"><p><a class="el" href="namespacearlib.html#a544f6817e2696d89923463118a457575a88897dfad3fa724d035439daed14b098" title="bidirectional_dijkstra()">arlib::bidirectional_dijkstra()</a> should exit because preconditions are violated. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab0373cc347db5812e02845b33b5b2208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0373cc347db5812e02845b33b5b2208">&#9670;&nbsp;</a></span>astar_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename AStarHeuristic , typename DeletedEdgeMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;Edge&gt; &gt; arlib::details::astar_shortest_path </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AStarHeuristic &amp;&#160;</td>
          <td class="paramname"><em>heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeletedEdgeMap &amp;&#160;</td>
          <td class="paramname"><em>deleted_edge_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a shortest path between two vertices on a filtered graph using an A* approach, provided the set of edges to filter and the heuristic. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">AStarHeuristic</td><td></td></tr>
    <tr><td class="paramname">DeletedEdgeMap</td><td>an <a class="el" href="classarlib_1_1details_1_1edge__deleted__filter.html#aaafb2469429935a69dfb1e146707fc50" title="The deleted edges map.">edge_deleted_filter::DeletedEdgeMap</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex </td></tr>
    <tr><td class="paramname">heuristic</td><td>The A* heuristic. </td></tr>
    <tr><td class="paramname">deleted_edge_map</td><td>The set of edges to filter from <code>G</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::optional of the list of edges from <code>s</code> to <code>t</code> if a path could be found. An empty optional otherwise. </dd></dl>

</div>
</div>
<a id="a35113696f3c3f449de4c36628050298c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35113696f3c3f449de4c36628050298c">&#9670;&nbsp;</a></span>build_edge_list_from_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PredecessorMap , typename Edge  = edge_of_t&lt;Graph&gt;, typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Edge&gt; arlib::details::build_edge_list_from_dijkstra </td>
          <td>(</td>
          <td class="paramtype">Graph const &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PredecessorMap &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a vector of kspwlo::Edge out of a PredecessorMap computed by a shortest path algorithm from <code>s</code> to <code>t</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vertex</td><td></td></tr>
    <tr><td class="paramname">PredecessorMap</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex </td></tr>
    <tr><td class="paramname">p</td><td>The PredecessorMap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the shortest path edges from <code>s</code> to <code>t</code>. </dd></dl>

</div>
</div>
<a id="a02c4c3482d63557fcfc6a5748caa7f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c4c3482d63557fcfc6a5748caa7f09">&#9670;&nbsp;</a></span>build_path_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;Graph&gt; arlib::details::build_path_from </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Vertex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph const &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a sequence of vertices of a graph <code>G</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vertex_descriptor</code>s of <code>path</code> must be vertices of <code>G</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A sequence of vertices of <code>G</code> representing a simple-path. </td></tr>
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </dd></dl>

</div>
</div>
<a id="a3a24d7e2f264023bb7309e932fe14d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a24d7e2f264023bb7309e932fe14d86">&#9670;&nbsp;</a></span>build_path_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename Vertex  = vertex_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarlib_1_1Path.html">Path</a>&lt;Graph&gt; arlib::details::build_path_from </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Vertex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph const &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a> from a sequence of vertices of a graph <code>G</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vertex_descriptor</code>s of <code>path</code> must be vertices of <code>G</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A model of a graph for which <code>edge(u, v, G)</code> is a valid expression. </td></tr>
    <tr><td class="paramname">WeightMap</td><td>The weight or "length" of each edge in the graph. The weights must all be non-negative, and the algorithm will throw a negative_edge exception is one of the edges is negative. The type WeightMap must be a model of Readable Property Map. The edge descriptor type of the graph needs to be usable as the key type for the weight map. The value type for this map must be the same as the value type of the distance map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A sequence of vertices of <code>G</code> representing a simple-path. </td></tr>
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">W</td><td>The Weight Property Map of <code>G</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed <a class="el" href="classarlib_1_1Path.html" title="A view of a graph to a simple path.">Path</a>. </dd></dl>

</div>
</div>
<a id="a9097e64acb35fcb19c9c435d0e264ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9097e64acb35fcb19c9c435d0e264ec1">&#9670;&nbsp;</a></span>check_candidate_validity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Edge , typename WeightMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool arlib::details::check_candidate_validity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unordered_set&lt; Edge, boost::hash&lt; Edge &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alternatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a candidate path satisfies the condition to add it the the alternative paths set. </p>
<p>That is: \(Sim(candidate, p_i) &lt; \theta, \forall p_i \in AlternativePaths\)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>The candidate path. </td></tr>
    <tr><td class="paramname">alternatives</td><td>The list of alternative paths. </td></tr>
    <tr><td class="paramname">theta</td><td>The similarity threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If <code>candidate</code> is sufficiently dissimilar to all the other alternative paths. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a941daa4e279f920870bef6757c54d5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941daa4e279f920870bef6757c54d5b7">&#9670;&nbsp;</a></span>check_feasibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arlib::details::check_feasibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether another alternative path can be found by ESX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>The vector of overlapping factors between <code>path_tmp</code> and the alternative paths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a solution can still be found. </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a id="a127a57ee19f9bf85aa121cd6f55441a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127a57ee19f9bf85aa121cd6f55441a4">&#9670;&nbsp;</a></span>compute_length_from_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename GWeightMap , typename Length  = value_of_t&lt;GWeightMap&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Length arlib::details::compute_length_from_edges </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GWeightMap const &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the length of the path in <code>candidate</code> using weights from <code>G</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>The candidate path </td></tr>
    <tr><td class="paramname">G</td><td>The graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of <code>candidate</code>, i.e. \(\sum_{e \in candidate} weight(e, G)\) </dd></dl>

</div>
</div>
<a id="adaa333b32bc9ab626594b7c1f7291c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa333b32bc9ab626594b7c1f7291c25">&#9670;&nbsp;</a></span>compute_priority()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename WeightMap , typename DeletedEdgeMap , typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int arlib::details::compute_priority </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeletedEdgeMap &amp;&#160;</td>
          <td class="paramname"><em>deleted_edge_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the ESX priority of an edge. </p>
<p>Quoting the reference paper:</p>
<blockquote class="doxtable">
<p>Given an edge e(a, b) on some alternative path p, let E_inc(a) be the set of all incoming edges e(n_i, a) to a from some node n_i in Nb} and E_out(b) be the set of all outgoing edges e(b, n_j) from b to some node n_j in Na}. First, ESX computes the set P_s which contains the shortest paths from every node n_i in E_inc(a) to every node n_j in E_out(b). Then, ESX defines the set P'_s which contains all paths p in P'_s that cross edge e. Finally, ESX assigns a priority to edge e, denoted by prio(e), which is set to cardinality of P'_s.</p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">AStarHeuristic</td><td></td></tr>
    <tr><td class="paramname">DeletedEdgeMap</td><td>an <a class="el" href="classarlib_1_1details_1_1edge__deleted__filter.html#aaafb2469429935a69dfb1e146707fc50" title="The deleted edges map.">edge_deleted_filter::DeletedEdgeMap</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">e</td><td>An edge of <code>G</code> </td></tr>
    <tr><td class="paramname">heuristic</td><td>An A* heuristic to use in performing shortest paths search. </td></tr>
    <tr><td class="paramname">deleted_edge_map</td><td>The set of edges to filter from <code>G</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The priority of <code>e</code>. </dd></dl>

</div>
</div>
<a id="a84c851f670287cae9d45545d2d84e0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c851f670287cae9d45545d2d84e0a8">&#9670;&nbsp;</a></span>dijkstra_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;Edge&gt; &gt; arlib::details::dijkstra_shortest_path </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Dijkstra shortest path from s to t using a <a class="el" href="classarlib_1_1details_1_1penalty__functor.html" title="A functor to return the penalized weight of an edge, to avoid changing the original graph weights.">penalty_functor</a> to gather edges weight instead of the Graph's weight property map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">PMap</td><td>The graph's weight property map. </td></tr>
    <tr><td class="paramname">Vertex</td><td>A vertex_descriptor. </td></tr>
    <tr><td class="paramname">Edge</td><td>An edge_descriptor. </td></tr>
    <tr><td class="paramname">Length</td><td>The edge weight type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex </td></tr>
    <tr><td class="paramname">penalty</td><td>A <a class="el" href="classarlib_1_1details_1_1penalty__functor.html" title="A functor to return the penalized weight of an edge, to avoid changing the original graph weights.">penalty_functor</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the edges of the shortest path from s to t. An empty optional if t is not reachable from s. </dd></dl>

</div>
</div>
<a id="a5190c73a0840b9e58be99cbcc7ad485c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5190c73a0840b9e58be99cbcc7ad485c">&#9670;&nbsp;</a></span>dijkstra_shortest_path_two_ways()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::vector&lt;Edge&gt; &gt; arlib::details::dijkstra_shortest_path_two_ways </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a>&lt; Length &gt; &amp;&#160;</td>
          <td class="paramname"><em>distance_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a>&lt; Length &gt; &amp;&#160;</td>
          <td class="paramname"><em>distance_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the shortest path between two vertices s and t, first from s to t and then from t to s. </p>
<p>The distances of each node in the shortest paths are stored in distance_s and distance_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">Vertex</td><td>A vertex_descriptor </td></tr>
    <tr><td class="paramname">Length</td><td>The edge weight type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
    <tr><td class="paramname">distance_s</td><td>A map from Vertex to its distance from <code>s</code> </td></tr>
    <tr><td class="paramname">distance_t</td><td>A map from Vertex to its distance from <code>t</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the edges of the shortest path from s to t. An empty optional if t is not reachable from s. </dd></dl>

</div>
</div>
<a id="a15a2bf0bdc7b17c10ba193d919cea238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a2bf0bdc7b17c10ba193d919cea238">&#9670;&nbsp;</a></span>init_distance_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename DistanceMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::details::init_distance_vector </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a DistanceMap with <code>infinite</code> value for each vertex in the graph. </p>
<dl class="section post"><dt>Postcondition</dt><dd>For each vertex <code>v</code> in <code>G</code>, <code>distance[v] = +inf</code>, given <code>inf = std::numeric_limits&lt;distance_type&gt;::max()</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::Graph. </td></tr>
    <tr><td class="paramname">DistanceMap</td><td>The distance PropertyMap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">distance</td><td>the DistanceMap to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee7d22ebb6f057f95cad08c14637e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee7d22ebb6f057f95cad08c14637e2b">&#9670;&nbsp;</a></span>init_edge_priorities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PrioritiesVector , typename WeightMap , typename EdgeMap , typename Index  = typename PrioritiesVector::size_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::details::init_edge_priorities </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>alternative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrioritiesVector &amp;&#160;</td>
          <td class="paramname"><em>edge_priorities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>alt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EdgeMap &amp;&#160;</td>
          <td class="paramname"><em>deleted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the edge priorities of an alternative path. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>edge_priorities</code> is a vector of std::priority_queue of size al least <code>alt_index</code> + 1.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>edge_priorities</code>[alt_index] queue is filled with pairs <code>(e, priority(e))</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">PrioritiesVector</td><td>a std::vector&lt;std::priority_queue&lt;std::pair&lt;Edge, Priority&gt;&gt;&gt; </td></tr>
    <tr><td class="paramname">AStarHeuristic</td><td></td></tr>
    <tr><td class="paramname">EdgeMap</td><td>an <a class="el" href="classarlib_1_1details_1_1edge__deleted__filter.html#aaafb2469429935a69dfb1e146707fc50" title="The deleted edges map.">edge_deleted_filter::DeletedEdgeMap</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alternative</td><td>The alternative path </td></tr>
    <tr><td class="paramname">edge_priorities</td><td>The edge priorities vector </td></tr>
    <tr><td class="paramname">alt_index</td><td>The index of <code>edge_priorities</code> where to store priorities at. </td></tr>
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">heuristic</td><td>An A* heuristic to use in performing shortest paths search. </td></tr>
    <tr><td class="paramname">deleted_edges</td><td>The set of edges to filter from <code>G</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413fa4118e821f61452f393ffe56333d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413fa4118e821f61452f393ffe56333d">&#9670;&nbsp;</a></span>init_edge_priorities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PrioritiesVector , typename Graph , typename WeightMap , typename EdgeMap , typename Edge  = edge_of_t&lt;Graph&gt;, typename Index  = typename PrioritiesVector::size_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::details::init_edge_priorities </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>alternative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrioritiesVector &amp;&#160;</td>
          <td class="paramname"><em>edge_priorities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>alt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacearlib_1_1details.html#ab74e1937db5f6e2f07835bdd80ed2d72">WeightMap</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EdgeMap &amp;&#160;</td>
          <td class="paramname"><em>deleted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the edge priorities of an alternative path. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>edge_priorities</code> is a vector of std::priority_queue of size al least <code>alt_index</code> + 1.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>edge_priorities</code>[alt_index] queue is filled with pairs <code>(e, priority(e))</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">PrioritiesVector</td><td>a std::vector&lt;std::priority_queue&lt;std::pair&lt;Edge, Priority&gt;&gt;&gt; </td></tr>
    <tr><td class="paramname">AStarHeuristic</td><td></td></tr>
    <tr><td class="paramname">EdgeMap</td><td>an <a class="el" href="classarlib_1_1details_1_1edge__deleted__filter.html#aaafb2469429935a69dfb1e146707fc50" title="The deleted edges map.">edge_deleted_filter::DeletedEdgeMap</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alternative</td><td>The alternative path </td></tr>
    <tr><td class="paramname">edge_priorities</td><td>The edge priorities vector </td></tr>
    <tr><td class="paramname">alt_index</td><td>The index of <code>edge_priorities</code> where to store priorities at. </td></tr>
    <tr><td class="paramname">G</td><td>The graph </td></tr>
    <tr><td class="paramname">heuristic</td><td>An A* heuristic to use in performing shortest paths search. </td></tr>
    <tr><td class="paramname">deleted_edges</td><td>The set of edges to filter from <code>G</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dca603b96ef5d69a5f35dfda5fb5ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dca603b96ef5d69a5f35dfda5fb5ec4">&#9670;&nbsp;</a></span>penalize_candidate_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename DistanceMap , typename PMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;, typename Length  = length_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void arlib::details::penalize_candidate_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarlib_1_1details_1_1penalty__functor.html">penalty_functor</a>&lt; PMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacearlib_1_1details.html#ac533ffdf859998c65d811a09b695d0f1">DistanceMap</a> &amp;&#160;</td>
          <td class="paramname"><em>distance_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ace617814ee15bcb2b6731cbe3cdbe956">PenBoundsMap</a>&lt; Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>penalty_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bound_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply penalization step to the candidate path. </p>
<dl class="section pre"><dt>Precondition</dt><dd>For each vertex <code>v</code> in <code>candidate</code> <code>distance_s</code> contains the shortest path distance of <code>v</code> from <code>s</code> </dd>
<dd>
For each vertex <code>v</code> in <code>candidate</code> <code>distance_t</code> contains the shortest path distance of <code>v</code> from <code>t</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>For each edge <code>e</code> in <code>candidate</code>, if <code>penalty_bounds[e] &lt; bound_limit</code>, <code>e</code> is penalized in <code>penalty</code> according to the following formula: <code>w(e)_new = w(e) + <code>p</code> * w(e)</code> </dd>
<dd>
For each edge <code>e</code> incoming to a vertex <code>u</code> in <code>candidate</code>, if <code>penalty_bounds[e] &lt; bound_limit</code>, <code>e</code> is penalized in <code>penalty</code> according to the following formula: <code>w(e)_new = w(e) + w(e) * (0.1 + <code>r</code> * <code>distance_t</code>[u] / <code>distance_t</code>[s])</code> </dd>
<dd>
For each edge <code>e</code> outgoing from a vertex <code>v</code> in <code>candidate</code>, if <code>penalty_bounds[e] &lt; bound_limit</code>, <code>e</code> is penalized in <code>penalty</code> according to the following formula: <code>w(e)_new = w(e) + w(e) * (0.1 + <code>r</code> * <code>distance_s</code>[v] / <code>distance_s</code>[t])</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::PropertyGraph having at least one edge property with tag boost::edge_weight_t. </td></tr>
    <tr><td class="paramname">DistanceMap</td><td>A DistanceMap. </td></tr>
    <tr><td class="paramname">PMap</td><td>The graph's weight property map. </td></tr>
    <tr><td class="paramname">Vertex</td><td>A vertex_descriptor. </td></tr>
    <tr><td class="paramname">Edge</td><td>An edge_descriptor. </td></tr>
    <tr><td class="paramname">Length</td><td>The edge weight type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>The candidate path. </td></tr>
    <tr><td class="paramname">G</td><td>The graph. </td></tr>
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
    <tr><td class="paramname">p</td><td>The penalty factor for edges in the candidate path. </td></tr>
    <tr><td class="paramname">r</td><td>The penalty factor for edges incoming and outgoing to/from vertices of the candidate path. </td></tr>
    <tr><td class="paramname">penalty</td><td>A <a class="el" href="classarlib_1_1details_1_1penalty__functor.html" title="A functor to return the penalized weight of an edge, to avoid changing the original graph weights.">penalty_functor</a>. </td></tr>
    <tr><td class="paramname">distance_s</td><td>A DistanceMap from s. </td></tr>
    <tr><td class="paramname">distance_t</td><td>A DistanceMap from t. </td></tr>
    <tr><td class="paramname">penalty_bounds</td><td>A PenBoundsMap. </td></tr>
    <tr><td class="paramname">bound_limit</td><td>The maximum number of times an edge can be penalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a317cc8632710c8359abe8d76016f5ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317cc8632710c8359abe8d76016f5ed6">&#9670;&nbsp;</a></span>shortest_path_contains_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename PredMap , typename Vertex  = vertex_of_t&lt;Graph&gt;, typename Edge  = edge_of_t&lt;Graph&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool arlib::details::shortest_path_contains_edge </td>
          <td>(</td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Edge&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PredMap &amp;&#160;</td>
          <td class="paramname"><em>predecessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the path from <code>s</code> to <code>t</code> contains edge <code>e</code> or not. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>predecessor</code> is the PredecessorMap filled by a Boost::Graph shortest path algorithm such that <code>predecessor[s] == s</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>A Boost::EdgeList graph </td></tr>
    <tr><td class="paramname">PredMap</td><td>A Boost::PredecessorMap </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex </td></tr>
    <tr><td class="paramname">e</td><td>The edge we want to check if present in <code>path(s -&gt; t)</code> </td></tr>
    <tr><td class="paramname">G</td><td>The graph containing edge <code>e</code> </td></tr>
    <tr><td class="paramname">predecessor</td><td>The predecessor map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If <code>e</code> is in the computed path from <code>s</code> to <code>t</code> </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a id="a615cd3e0b8399e420c9618c0b74153d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615cd3e0b8399e420c9618c0b74153d1">&#9670;&nbsp;</a></span>switch_direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacearlib_1_1details.html#ab0e3013ce3650ead65afcd6e52dcb232">Direction</a> arlib::details::switch_direction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacearlib_1_1details.html#ab0e3013ce3650ead65afcd6e52dcb232">Direction</a>&#160;</td>
          <td class="paramname"><em>prev_dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the opposite direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_dir</td><td>The current execution direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direction::forward if <code>prev_dir</code> == Direction::backward. Direction::backward otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
